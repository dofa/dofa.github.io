
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Do Far</title>
  <meta name="author" content="dofa">

  
  <meta name="description" content="安装shadowsocks包 npm install -g shadowsocks 创建 config.json { "server":"yourip or yourdomain", "server_port":8388, "local_port":1080, "password":"xxxxxx &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://blog.dofa.org">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/atom.xml" rel="alternate" title="Do Far" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-48748469-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Do Far</a></h1>
  
    <h2>There is a will, there is a way.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:blog.dofa.org" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">归档</a></li>
  <li><a href="/github">Github</a></li>
  <li><a href="/about">关于我</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/13/install-shadowsocks-nodejs/">安装shadowsocks-nodejs</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-13T14:18:30-07:00" pubdate data-updated="true">May 13<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/05/13/install-shadowsocks-nodejs/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><h2>安装shadowsocks包</h2>

<pre><code>npm install -g shadowsocks
</code></pre>

<h2>创建 <code>config.json</code></h2>

<pre><code>{
    "server":"yourip or yourdomain",
    "server_port":8388,
    "local_port":1080,
    "password":"xxxxxx",
    "timeout":600,
    "method":"rc4",
    "local_address":"127.0.0.1"
}
</code></pre>

<h2>安装<code>coffee-script</code></h2>

<pre><code>npm install -g coffee-script
</code></pre>

<h2>后台运行</h2>

<pre><code>sudo nohup ssserver &gt; log &amp;
</code></pre>

<h2><code>local</code>端运行</h2>

<pre><code>sslocal
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/13/install-nodejs-in-debian/">在debian上安装nodejs</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-13T13:42:30-07:00" pubdate data-updated="true">May 13<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/05/13/install-nodejs-in-debian/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><h2>安装编译包</h2>

<pre><code>sudo apt-get install python g++ make checkinstall
</code></pre>

<h2>获取最新的 <code>node</code> 源码</h2>

<pre><code>mkdir ~/src &amp;&amp; cd ~/src
wget -N http://nodejs.org/dist/node-latest.tar.gz
tar xzvf node-latest.tar.gz &amp;&amp; cd node-v*
</code></pre>

<h2>配置编译源码</h2>

<pre><code>./configure
sudo checkinstall
</code></pre>

<p>注意，运行 checkinstall 需要 sudo，之后选择 3，将 node 的版本号前的 v 去掉， 例如，这里安装的版本为 v0.10.28，改为 0.10.28 即可。
这里编译会比较久，需要耐心等待，特别是在 pi 下。</p>

<h2>安装（<code>-i</code>）和卸载（<code>-r</code>）</h2>

<pre><code>sudo dpkg -i node_*
sudo dpkg -r node
</code></pre>

<h2>查看 nodejs 和 npm 的版本</h2>

<pre><code>node -v
npm -v
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/11/bash-shortcut/">bash快捷操作</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-11T09:51:30-07:00" pubdate data-updated="true">May 11<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/05/11/bash-shortcut/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><p>经常使用bash，但是bash shell使用的效率一直不高，今天终于发现了有快捷键，赶快记录下来。</p>

<h2>编辑命令</h2>

<ul>
<li><code>Ctrl + a</code> ：移到命令行首</li>
<li><code>Ctrl + e</code> ：移到命令行尾</li>
<li><code>Ctrl + f</code> ：按字符前移（右向）</li>
<li><code>Ctrl + b</code> ：按字符后移（左向）</li>
<li><code>Alt + f</code> ：按单词前移（右向）</li>
<li><code>Alt + b</code> ：按单词后移（左向）</li>
<li><code>Ctrl + xx</code>：在命令行首和光标之间移动</li>
<li><code>Ctrl + u</code> ：从光标处删除至命令行首</li>
<li><code>Ctrl + k</code> ：从光标处删除至命令行尾</li>
<li><code>Ctrl + w</code> ：从光标处删除至字首</li>
<li><code>Alt + d</code> ：从光标处删除至字尾</li>
<li><code>Ctrl + d</code> ：删除光标处的字符</li>
<li><code>Ctrl + h</code> ：删除光标前的字符</li>
<li><code>Ctrl + y</code> ：粘贴至光标后</li>
<li><code>Alt + c</code> ：从光标处更改为首字母大写的单词</li>
<li><code>Alt + u</code> ：从光标处更改为全部大写的单词</li>
<li><code>Alt + l</code> ：从光标处更改为全部小写的单词</li>
<li><code>Ctrl + t</code> ：交换光标处和之前的字符</li>
<li><code>Alt + t</code> ：交换光标处和之前的单词</li>
<li><code>Alt + Backspace</code> ：与 <code>Ctrl + w</code> 类似</li>
</ul>


<h2>重新执行命令</h2>

<ul>
<li><code>Ctrl + r</code> ：逆向搜索命令历史</li>
<li><code>Ctrl + g</code> ：从历史搜索模式退出</li>
<li><code>Ctrl + p</code> ：历史中的上一条命令</li>
<li><code>Ctrl + n</code> ：历史中的下一条命令</li>
<li><code>Alt + .</code> ：使用上一条命令的最后一个参数</li>
</ul>


<h2>控制命令</h2>

<ul>
<li><code>Ctrl + l</code> ：清屏</li>
<li><code>Ctrl + o</code> ：执行当前命令，并选择上一条命令</li>
<li><code>Ctrl + s</code> ：阻止屏幕输出</li>
<li><code>Ctrl + q</code> ：允许屏幕输出</li>
<li><code>Ctrl + c</code> ：终止命令</li>
<li><code>Ctrl + z</code> ：挂起命令</li>
</ul>


<h2>Bang (!) 命令</h2>

<ul>
<li><code>!!</code> ：执行上一条命令</li>
<li><code>!blah</code> ：执行最近的以 <code>blah</code> 开头的命令，如 <code>!ls</code></li>
<li><code>!blah:p</code> ：仅打印输出，而不执行</li>
<li><code>!$</code> ：上一条命令的最后一个参数，与 <code>Alt + .</code> 相同</li>
<li><code>!$:p</code> ：打印输出 <code>!$</code> 的内容</li>
<li><code>!*</code> ：上一条命令的所有参数</li>
<li><code>!*:p</code> ：打印输出 <code>!*</code> 的内容</li>
<li><code>^blah</code> ：删除上一条命令中的 <code>blah</code></li>
<li><code>^blah^foo</code> ：将上一条命令中的 <code>blah</code> 替换为 <code>foo</code></li>
<li><code>^blah^foo^</code> ：将上一条命令中所有的 <code>blah</code> 都替换为 <code>foo</code></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/08/git-settings/">常用git设置</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-08T13:52:50-07:00" pubdate data-updated="true">May 8<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/05/08/git-settings/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><h2>Git基本配置</h2>

<pre><code>git config --global user.name 'dofa'
git config --global user.email 'xxx@xxx.com'
</code></pre>

<h2>Git使用代理</h2>

<pre><code>git config --global http.proxy http://127.0.0.1:8087
git config --global https.proxy http://127.0.0.1:8087
git config --global http.sslverify false
</code></pre>

<p><code>http.sslverify</code>设置为<code>false</code>可以加快同步速度。</p>

<h2>Git显示漂亮日志</h2>

<pre><code>git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative --show-signature"
</code></pre>

<h2>Git其它技巧</h2>

<h3>前一个分支</h3>

<p>快速检出上一个分支：</p>

<pre><code>$ git checkout -
# Switched to branch 'master'

$ git checkout -
# Switched to branch 'next'

$ git checkout -
# Switched to branch 'master'   
</code></pre>

<h3><code>Stripspace</code>命令</h3>

<p><code>Git Stripspace</code>命令可以:</p>

<ul>
<li>去掉行尾空白符</li>
<li>多个空行压缩成一行</li>
<li>必要时在文件末尾增加一个空行</li>
</ul>


<p>使用此命令时必须传入一个文件，像这样：</p>

<pre><code>$ git stripspace &lt; README.md    
</code></pre>

<h3>提交空改动</h3>

<p>可以使用<code>--allow-empty</code>选项强制创建一个没有任何改动的提交：</p>

<pre><code>$ git commit -m "Big-ass commit" --allow-empty
</code></pre>

<p>这样做在如下几种情况下是有意义的：</p>

<ul>
<li>标记一批工作或一个新功能的开始。</li>
<li>记录你对项目进行了跟代码无关的改动。</li>
<li>跟使用你仓库的其他人交流。</li>
<li>作为仓库的第一次提交，因为第一次提交日后是不能被<code>rebase</code>的： <code>git commit -m "init repo" --allow-empty</code>.</li>
</ul>


<h3>更直观的Git Status</h3>

<p>在命令行输入如下命令:</p>

<pre><code>$ git status -sb
</code></pre>

<h3>Git查询</h3>

<p><code>Git</code>查询运行你在之前的所有提交信息里进行搜索，找到其中和搜索条件相匹配的最近的一条。</p>

<pre><code>$ git show :/query
</code></pre>

<p>这里 <code>query</code> （区别大小写）是你想要搜索的词语， 这条命令会找到包含这个词语的最后那个提交并显示变动详情。</p>

<pre><code>$ git show :/typo
</code></pre>

<p>按 <code>q</code> 键退出命令。</p>

<h3>合并分支</h3>

<p>输入命令:</p>

<pre><code>$ git branch --merged
</code></pre>

<p>这会显示所有已经合并到你当前分支的分支列表。</p>

<p>相反地：</p>

<pre><code>$ git branch --no-merged
</code></pre>

<p>会显示所有还没有合并到你当前分支的分支列表。</p>

<h3>使用网页查看本地仓库</h3>

<p>使用<code>Git</code>的 <code>instaweb</code> 可以立即在 <code>gitweb</code>中浏览你的工作仓库。这个命令是个简单的脚步，配置了<code>gitweb</code>和用来浏览本地仓库的<code>Web</code>服务器。（译者注：默认需要<code>lighttpd</code>支持）</p>

<pre><code>$ git instaweb
</code></pre>

<h3><code>Git</code>命令自定义别名</h3>

<p>别名用来帮助你定义自己的<code>git</code>命令。比如你可以定义 <code>git a</code> 来运行 <code>git add --all</code>。</p>

<p>要添加一个别名， 一种方法是打开 <code>~/.gitconfig</code> 文件并添加如下内容：</p>

<pre><code>[alias]
  co = checkout
  cm = commit
  p = push
  # Show verbose output about tags, branches or remotes
  tags = tag -l
  branches = branch -a
  remotes = remote -v
</code></pre>

<p>&hellip;或者在命令行里键入：</p>

<pre><code>$ git config --global alias.new_alias git_function
</code></pre>

<p>例如：</p>

<pre><code>$ git config --global alias.cm commit
</code></pre>

<p>指向多个命令的别名可以用引号来定义：</p>

<pre><code>$ git config --global alias.ac 'add -A . &amp;&amp; commit' 
</code></pre>

<h3>一些有用的别名：</h3>

<table>
<thead>
<tr>
<th>别名 Alias </th>
<th> 命令 Command </th>
<th> 如何设置 What to Type </th>
</tr>
</thead>
<tbody>
<tr>
<td><code>git cm</code> </td>
<td> <code>git commit</code> </td>
<td> <code>git config --global alias.cm commit</code> </td>
</tr>
<tr>
<td><code>git co</code> </td>
<td> <code>git checkout</code> </td>
<td> <code>git config --global alias.co checkout</code> </td>
</tr>
<tr>
<td><code>git ac</code> </td>
<td> <code>git add . -A</code> <code>git commit</code> </td>
<td> <code>git config --global alias.ac '!git add -A &amp;&amp; git commit'</code> </td>
</tr>
<tr>
<td><code>git st</code> </td>
<td> <code>git status -sb</code> </td>
<td> <code>git config --global alias.st 'status -sb'</code> </td>
</tr>
<tr>
<td><code>git tags</code> </td>
<td> <code>git tag -l</code> </td>
<td> <code>git config --global alias.tags 'tag -l'</code> </td>
</tr>
<tr>
<td><code>git branches</code> </td>
<td> <code>git branch -a</code> </td>
<td> <code>git config --global alias.branches 'branch -a'</code> </td>
</tr>
<tr>
<td><code>git remotes</code> </td>
<td> <code>git remote -v</code> </td>
<td> <code>git config --global alias.remotes 'remote -v'</code> </td>
</tr>
<tr>
<td><code>git lg</code> </td>
<td> <code>git log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --</code> </td>
<td> <code>git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --"</code> </td>
</tr>
</tbody>
</table>


<h3>自动更正</h3>

<pre><code>$ git config --global help.autocorrect 1
</code></pre>

<h3>带颜色输出</h3>

<pre><code>$ git config --global color.ui 1
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/08/ssh-proxy-settings/">ssh代理设置</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-08T13:28:50-07:00" pubdate data-updated="true">May 8<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/05/08/ssh-proxy-settings/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><p>有两种方式实现ssh代理，一种是ssh命令行，另外一种使用putty的plink工具。</p>

<h2>ssh命令行</h2>

<pre><code>ssh -qTfnN -D 8087 用户名@远程ssh主机名
</code></pre>

<p>上面的8087是本地未被占用的端口，可以自己选择。其它参数的意思是：</p>

<pre><code>-q :- be very quite, we are acting only as a tunnel.
-T :- Do not allocate a pseudo tty, we are only acting a tunnel.
-f :- move the ssh process to background, as we don’t want to interact with this ssh session directly.
-N :- Do not execute remote command.
-n :- redirect standard input to /dev/null. 
</code></pre>

<h4>remote端口占用</h4>

<pre><code>sudo netstat -antpl  | grep ssh
</code></pre>

<p><code>kill</code>进程</p>

<pre><code>sudo kill -9 xxxx
</code></pre>

<h2>plink工具</h2>

<pre><code>plink -C -D 127.0.0.1:8087 -N -pw 密码 用户名@远程ssh主机名 
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/26/build-angularjs-and-bootstrap-environment-with-angular-seed/">使用angular-seed搭建angularjs和bootstrap开发环境</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-26T10:36:50-07:00" pubdate data-updated="true">Apr 26<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/04/26/build-angularjs-and-bootstrap-environment-with-angular-seed/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><h2>Clone angular-seed</h2>

<pre><code>git clone https://github.com/angular/angular-seed.git
cd angular-seed
</code></pre>

<h2>Install Dependencies</h2>

<pre><code>npm install -g bower
npm install
</code></pre>

<p>如果遇到timeout问题，请设置代理：</p>

<pre><code>npm config set proxy=http://127.0.0.1:8087
</code></pre>

<h2>Run the Application</h2>

<pre><code>npm start
</code></pre>

<p>访问<code>http://localhost:8000/app/index.html</code>，看环境是否搭建ok。</p>

<h2>安装bootstrap</h2>

<p>在<code>bower.json</code>中增加<code>angular-bootstrap</code>和<code>bootstrap</code>：</p>

<pre><code>{
  "name": "angular-seed",
  "description": "A starter project for AngularJS",
  "version": "0.0.0",
  "homepage": "https://github.com/angular/angular-seed",
  "license": "MIT",
  "private": true,
  "dependencies": {
    "angular": "1.2.x",
    "angular-route": "1.2.x",
    "angular-loader": "1.2.x",
    "angular-mocks": "~1.2.15",
    "angular-bootstrap": "",
    "bootstrap": ""
  }
}
</code></pre>

<p>再执行：</p>

<pre><code>npm install
</code></pre>

<p>修改<code>app.js</code>：</p>

<pre><code>'use strict';


// Declare app level module which depends on filters, and services
angular.module('myApp', [
  'ngRoute',
  'myApp.filters',
  'myApp.services',
  'myApp.directives',
  'myApp.controllers',
  'ui.bootstrap'
]).
config(['$routeProvider', function($routeProvider) {
  $routeProvider.when('/view1', {templateUrl: 'partials/partial1.html', controller: 'MyCtrl1'});
  $routeProvider.when('/view2', {templateUrl: 'partials/partial2.html', controller: 'MyCtrl2'});
  $routeProvider.otherwise({redirectTo: '/view1'});
}]);
</code></pre>

<p>在<code>index.html</code>中增加：</p>

<pre><code>&lt;link rel="stylesheet" href="../bower_components/bootstrap/dist/css/bootstrap.css"/&gt;
</code></pre>

<p>和</p>

<pre><code>&lt;script src="../bower_components/angular-bootstrap/ui-bootstrap-tpls.js"&gt;&lt;/script&gt;
</code></pre>

<p>同样需要在<code>index-async.html</code>中增加：</p>

<pre><code>&lt;script src="../bower_components/angular-bootstrap/ui-bootstrap-tpls.js"&gt;&lt;/script&gt;
</code></pre>

<h3>Bootstrap测试</h3>

<p>使用<code>http://angular-ui.github.io/bootstrap/</code>中的测试code，进行测试，即可看到同样的UI效果。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/26/use-git-svn/">使用git-svn</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-26T07:38:50-07:00" pubdate data-updated="true">Apr 26<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/04/26/use-git-svn/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><p>个人比较习惯git，无奈目前单位使用svn，尽管svn相当不好用。今天查找了一下解决方法，本地使用git，服务器为svn类型。</p>

<h2>从svn clone出项目</h2>

<pre><code>git svn clone -s https://svn.xxx.com/svn/xxx
git svn show-ignore &gt;&gt; .git/info/exclude 
</code></pre>

<h2>建立本地工作分支</h2>

<pre><code>git checkout -b work 
</code></pre>

<p>现在可以正常使用git命令了</p>

<h2>提交回svn的过程</h2>

<pre><code>git checkout master  
git merge work  
git svn rebase  
git svn dcommit 
</code></pre>

<h2>冲突解决</h2>

<pre><code>git svn rebase 
</code></pre>

<p>提示有冲突，手动解决冲突，然后：</p>

<pre><code>git add .
git rebase --continue
git svn dcommit
</code></pre>

<p>执行后，发现本地的commit也跟server上的有同步。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/24/use-oh-my-zsh-instead-of-bash/">使用oh my zsh替代bash</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-24T14:30:50-07:00" pubdate data-updated="true">Apr 24<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/04/24/use-oh-my-zsh-instead-of-bash/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><h2>安装zsh</h2>

<pre><code>apt-get install zsh
</code></pre>

<h2>安装OH-My-ZSH</h2>

<h4>手动安装</h4>

<pre><code>cd ~
git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh

cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
</code></pre>

<p>设定为默认bash</p>

<pre><code>chsh -s /bin/zsh
</code></pre>

<h4>自动安装</h4>

<p>via <code>curl</code></p>

<pre><code>curl -L http://install.ohmyz.sh | sh
</code></pre>

<p>via <code>wget</code></p>

<pre><code>wget --no-check-certificate http://install.ohmyz.sh -O - | sh
</code></pre>

<h2>修改putty不能显示的字符</h2>

<p><code>~/.oh-my-zsh/themes/robbyrussell.zsh-theme</code></p>

<pre><code>#PROMPT='%{$fg_bold[red]%}➜ %{$fg_bold[green]%}%p %{$fg[cyan]%}%c %{$fg_bold[blue]%}$(git_prompt_info)%{$fg_bold[blue]%} % %{$reset_color%}'
PROMPT='%{$fg_bold[red]%}# %{$fg_bold[green]%}%p %{$fg[cyan]%}%c %{$fg_bold[blue]%}$(git_prompt_info)%{$fg_bold[blue]%} % %{$reset_color%}'
ZSH_THEME_GIT_PROMPT_PREFIX="git:(%{$fg[red]%}"
ZSH_THEME_GIT_PROMPT_SUFFIX="%{$reset_color%}"
#ZSH_THEME_GIT_PROMPT_DIRTY="%{$fg[blue]%}) %{$fg[yellow]%}✗%{$reset_color%}"
ZSH_THEME_GIT_PROMPT_DIRTY="%{$fg[blue]%}) %{$fg[yellow]%}X %{$reset_color%}"
ZSH_THEME_GIT_PROMPT_CLEAN="%{$fg[blue]%})"
</code></pre>

<p>使用更改后的配置：</p>

<pre><code>source `~/.oh-my-zsh/themes/robbyrussell.zsh-theme`
</code></pre>

<h2>OH-My-ZSH的使用</h2>

<ul>
<li>强大的历史纪录功能，输入 grep 然后用上下箭头可以翻阅你执行的所有 grep 命令。</li>
<li>智能拼写纠正，输入gtep mactalk * -R，系统会提示：zsh: correct ‘gtep’ to ‘grep’ [nyae]? 比妹纸贴心吧，她们向来都是让你猜的……</li>
<li>各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下 tab 键，补全项可以使用 ctrl+n/p/f/b上下左右切换。比如你想杀掉 java 的进程，只需要输入 kill java + tab键，如果只有一个 java 进程，zsh 会自动替换为进程的 pid，如果有多个则会出现选择项供你选择。ssh + 空格 + 两个tab键，zsh会列出所有访问过的主机和用户名进行补全</li>
<li>目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。</li>
<li>在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。</li>
<li>通配符搜索：ls -l <em>*/</em>.sh，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find，文件太多就歇菜了。</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/07/learning-angularjs-notes-XHRs-and-dependency-injection/">Angularjs学习笔记-XHR和依赖注入</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-07T21:55:50-07:00" pubdate data-updated="true">Apr 7<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/04/07/learning-angularjs-notes-XHRs-and-dependency-injection/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><p>到现在为止，我们使用是硬编码的三条手机记录数据集。现在我们使用AngularJS一个内置服务$http来获取一个更大的手机记录数据集。我们将使用AngularJS的依赖注入（dependency injection (DI)）功能来为PhoneListCtrl控制器提供这个AngularJS服务。</p>

<h2>数据</h2>

<p>你项目当中的<code>app/phones/phones.json</code>文件是一个数据集，它以<code>JSON</code>格式存储了一张更大的手机列表。</p>

<p>下面是这个文件的一个样例：</p>

<pre><code>[
 {
  "age": 13,
  "id": "motorola-defy-with-motoblur",
  "name": "Motorola DEFY\u2122 with MOTOBLUR\u2122",
  "snippet": "Are you ready for everything life throws your way?"
  ...
 },
...
]
</code></pre>

<h2>Controller</h2>

<p>We&rsquo;ll use Angular&rsquo;s <code>$http</code> service in our controller to make an HTTP request to your web server to fetch the data in the <code>app/phones/phones.json</code> file. <code>$http</code> is just one of several built-in <code>Angular services</code> that handle common operations in web apps. Angular injects these services for you where you need them.</p>

<p>Services are managed by Angular&rsquo;s <code>DI subsystem</code>. Dependency injection helps to make your web apps both well-structured (e.g., separate components for presentation, data, and control) and loosely coupled (dependencies between components are not resolved by the components themselves, but by the DI subsystem).</p>

<p><code>app/js/controllers.js:</code></p>

<pre><code>var phonecatApp = angular.module('phonecatApp', []);

phonecatApp.controller('PhoneListCtrl', function ($scope, $http) {
  $http.get('phones/phones.json').success(function(data) {
    $scope.phones = data;
  });

  $scope.orderProp = 'age';
});
</code></pre>

<p><code>$http</code> makes an HTTP GET request to our web server, asking for <code>phones/phones.json</code> (the url is relative to our <code>index.html</code> file). The server responds by providing the data in the json file. (The response might just as well have been dynamically generated by a backend server. To the browser and our app they both look the same. For the sake of simplicity we used a json file in this tutorial.)</p>

<p>The <code>$http</code> service returns a promise object with a success method. We call this method to handle the asynchronous response and assign the phone data to the scope controlled by this controller, as a model called phones. Notice that Angular detected the json response and parsed it for us!</p>

<p>To use a service in Angular, you simply declare the names of the dependencies you need as arguments to the controller&rsquo;s constructor function, as follows:</p>

<pre><code>phonecatApp.controller('PhoneListCtrl', function ($scope, $http) {...}
</code></pre>

<p>Angular&rsquo;s dependency injector provides services to your controller when the controller is being constructed. The dependency injector also takes care of creating any transitive dependencies the service may have (services often depend upon other services).</p>

<p>Note that the names of arguments are significant, because the injector uses these to look up the dependencies.</p>

<h2>$ Prefix Naming Convention</h2>

<p>You can create your own services, and in fact we will do exactly that in step 11. As a naming convention, Angular&rsquo;s built-in services, Scope methods and a few other Angular APIs have a <code>$</code> prefix in front of the name.</p>

<p>The <code>$</code> prefix is there to namespace Angular-provided services. To prevent collisions it&rsquo;s best to avoid naming your services and models anything that begins with a <code>$</code>.</p>

<p>If you inspect a Scope, you may also notice some properties that begin with <code>$$</code>. These properties are considered private, and should not be accessed or modified.</p>

<h2>A Note on Minification</h2>

<p>Since Angular infers the controller&rsquo;s dependencies from the names of arguments to the controller&rsquo;s constructor function, if you were to minify the JavaScript code for PhoneListCtrl controller, all of its function arguments would be minified as well, and the dependency injector would not be able to identify services correctly.</p>

<p>We can overcome this problem by annotating the function with the names of the dependencies, provided as strings, which will not get minified. There are two ways to provide these injection annotations:</p>

<ul>
<li>Create a <code>$inject</code> property on the controller function which holds an array of strings. Each string in the array is the name of the service to inject for the corresponding parameter. In our example we would write:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function PhoneListCtrl($scope, $http) {...}
</span><span class='line'>PhoneListCtrl.$inject = ['$scope', '$http'];
</span><span class='line'>phonecatApp.controller('PhoneListCtrl', PhoneListCtrl);</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Use an inline annotation where, instead of just providing the function, you provide an array. This array contains a list of the service names, followed by the function itself.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function PhoneListCtrl($scope, $http) {...}
</span><span class='line'>phonecatApp.controller('PhoneListCtrl', ['$scope', '$http', PhoneListCtrl]);</span></code></pre></td></tr></table></div></figure>


<p>Both of these methods work with any function that can be injected by Angular, so it&rsquo;s up to your project&rsquo;s style guide to decide which one you use.</p>

<p>When using the second method, it is common to provide the constructor function inline as an anonymous function when registering the controller:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>phonecatApp.controller('PhoneListCtrl', ['$scope', '$http', function($scope, $http) {...}]);</span></code></pre></td></tr></table></div></figure>


<p>From this point onward, we&rsquo;re going to use the inline method in the tutorial. With that in mind, let&rsquo;s add the annotations to our PhoneListCtrl:</p>

<p><code>app/js/controllers.js:</code></p>

<pre><code>var phonecatApp = angular.module('phonecatApp', []);

phonecatApp.controller('PhoneListCtrl', ['$scope', '$http',
  function ($scope, $http) {
    $http.get('phones/phones.json').success(function(data) {
      $scope.phones = data;
    });

    $scope.orderProp = 'age';
  }]);
</code></pre>

<h2>Test</h2>

<p><code>test/unit/controllersSpec.js:</code></p>

<p>Because we started using dependency injection and our controller has dependencies, constructing the controller in our tests is a bit more complicated. We could use the new operator and provide the constructor with some kind of fake $http implementation. However, Angular provides a mock $http service that we can use in unit tests. We configure &ldquo;fake&rdquo; responses to server requests by calling methods on a service called $httpBackend:</p>

<pre><code>describe('PhoneCat controllers', function() {

  describe('PhoneListCtrl', function(){
    var scope, ctrl, $httpBackend;

    // Load our app module definition before each test.
    beforeEach(module('phonecatApp'));

    // The injector ignores leading and trailing underscores here (i.e. _$httpBackend_).
    // This allows us to inject a service but then attach it to a variable
    // with the same name as the service.
    beforeEach(inject(function(_$httpBackend_, $rootScope, $controller) {
      $httpBackend = _$httpBackend_;
      $httpBackend.expectGET('phones/phones.json').
          respond([{name: 'Nexus S'}, {name: 'Motorola DROID'}]);

      scope = $rootScope.$new();
      ctrl = $controller('PhoneListCtrl', {$scope: scope});
    }));
</code></pre>

<p>Note: Because we loaded Jasmine and angular-mocks.js in our test environment, we got two helper methods module and inject that we&rsquo;ll use to access and configure the injector.</p>

<p>We created the controller in the test environment, as follows:</p>

<ul>
<li><p>We used the inject helper method to inject instances of <code>$rootScope</code>, <code>$controller</code> and <code>$httpBackend</code> services into the Jasmine&rsquo;s beforeEach function. These instances come from an injector which is recreated from scratch for every single test. This guarantees that each test starts from a well known starting point and each test is isolated from the work done in other tests.</p></li>
<li><p>We created a new scope for our controller by calling <code>$rootScope.$new()</code></p></li>
<li><p>We called the injected <code>$controller</code> function passing the name of the <code>PhoneListCtrl</code> controller and the created scope as parameters.</p></li>
</ul>


<p>Because our code now uses the $http service to fetch the phone list data in our controller, before we create the PhoneListCtrl child scope, we need to tell the testing harness to expect an incoming request from the controller. To do this we:</p>

<ul>
<li><p>Request <code>$httpBackend</code> service to be injected into our beforeEach function. This is a mock version of the service that in a production environment facilitates all XHR and JSONP requests. The mock version of this service allows you to write tests without having to deal with native APIs and the global state associated with them — both of which make testing a nightmare.</p></li>
<li><p>Use the <code>$httpBackend.expectGET</code> method to train the $httpBackend service to expect an incoming HTTP request and tell it what to respond with. Note that the responses are not returned until we call the $httpBackend.flush method.</p></li>
</ul>


<p>Now we will make assertions to verify that the phones model doesn&rsquo;t exist on scope before the response is received:</p>

<pre><code>it('should create "phones" model with 2 phones fetched from xhr', function() {
  expect(scope.phones).toBeUndefined();
  $httpBackend.flush();

  expect(scope.phones).toEqual([{name: 'Nexus S'},
                               {name: 'Motorola DROID'}]);
});
</code></pre>

<ul>
<li><p>We flush the request queue in the browser by calling <code>$httpBackend.flush()</code>. This causes the promise returned by the $http service to be resolved with the trained response.</p></li>
<li><p>We make the assertions, verifying that the phone model now exists on the scope.</p></li>
</ul>


<p>Finally, we verify that the default value of orderProp is set correctly:</p>

<pre><code>it('should set the default value of orderProp model', function() {
  expect(scope.orderProp).toBe('age');
});
</code></pre>

<p>You should now see the following output in the Karma tab:</p>

<pre><code>Chrome 22.0: Executed 2 of 2 SUCCESS (0.028 secs / 0.007 secs)
</code></pre>

<h2>AngularjsXHR和依赖注入演示</h2>

<p><a href="/phonecat/step-5/app/">AngularjsXHR和依赖注入</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/07/learning-angularjs-notes-two-way-data-bingding/">Angularjs学习笔记-双向绑定</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-07T21:11:50-07:00" pubdate data-updated="true">Apr 7<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/04/07/learning-angularjs-notes-two-way-data-bingding/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><p>动态排序可以这样实现，添加一个新的模型属性，把它和迭代器集成起来，然后让数据绑定完成剩下的事情。</p>

<h2>模板</h2>

<p><code>app/index.html:</code></p>

<pre><code>Search: &lt;input ng-model="query"&gt;
Sort by:
&lt;select ng-model="orderProp"&gt;
    &lt;option value="name"&gt;Alphabetical&lt;/option&gt;
    &lt;option value="age"&gt;Newest&lt;/option&gt;
&lt;/select&gt;


&lt;ul class="phones"&gt;
    &lt;li ng-repeat="phone in phones | filter:query | orderBy:orderProp"&gt;

        &lt;p&gt;&lt;/p&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>我们在<code>index.html</code>中做了如下更改：</p>

<ul>
<li><p>首先，我们增加了一个叫做<code>orderProp</code>的<code>&lt;select&gt;</code>标签，这样我们的用户就可以选择我们提供的两种排序方法。</p></li>
<li><p>然后，在<code>filter</code>过滤器后面添加一个<code>orderBy</code>过滤器用其来处理进入迭代器的数据。<code>orderBy</code>过滤器以一个数组作为输入，复制一份副本，然后把副本重排序再输出到迭代器。</p></li>
</ul>


<p><code>AngularJS</code>在<code>select</code>元素和<code>orderProp</code>模型之间创建了一个双向绑定。而后，<code>orderProp</code>会被用作<code>orderBy</code>过滤器的输入。</p>

<p>正如我们在步骤3中讨论数据绑定和迭代器的时候所说的一样，无论什么时候数据模型发生了改变（比如用户在下拉菜单中选了不同的顺序），AngularJS的数据绑定会让视图自动更新。没有任何笨拙的DOM操作！</p>

<h2>控制器</h2>

<p><code>app/js/controllers.js:</code></p>

<pre><code>var phonecatApp = angular.module('phonecatApp', []);

phonecatApp.controller('PhoneListCtrl', function ($scope) {
  $scope.phones = [
    {'name': 'Nexus S',
     'snippet': 'Fast just got faster with Nexus S.',
     'age': 1},
    {'name': 'Motorola XOOM™ with Wi-Fi',
     'snippet': 'The Next, Next Generation tablet.',
     'age': 2},
    {'name': 'MOTOROLA XOOM™',
     'snippet': 'The Next, Next Generation tablet.',
     'age': 3}
  ];

  $scope.orderProp = 'age';
});
</code></pre>

<ul>
<li>我们修改了<code>phones</code>模型—— 手机的数组 ——为每一个手机记录其增加了一个<code>age</code>属性。我们会根据<code>age</code>属性来对手机进行排序。</li>
<li>我们在控制器代码里加了一行让<code>orderProp</code>的默认值为<code>age</code>。如果我们不设置默认值，这个模型会在我们的用户在下拉菜单选择一个顺序之前一直处于未初始化状态。</li>
</ul>


<p>现在我们该好好谈谈双向数据绑定了。注意到当应用在浏览器中加载时，“Newest”在下拉菜单中被选中。这是因为我们在控制器中把<code>orderProp</code>设置成了‘age’。所以绑定在从我们模型到用户界面的方向上起作用——即数据从模型到视图的绑定。现在当你在下拉菜单中选择“Alphabetically”，数据模型会被同时更新，并且手机列表数组会被重新排序。这个时候数据绑定从另一个方向产生了作用——即数据从视图到模型的绑定。</p>

<h2>Test</h2>

<p>The changes we made should be verified with both a unit test and an end-to-end test. Let&rsquo;s look at the unit test first.</p>

<p><code>test/unit/controllersSpec.js:</code></p>

<pre><code>describe('PhoneCat controllers', function() {

  describe('PhoneListCtrl', function(){
    var scope, ctrl;

    beforeEach(module('phonecatApp'));

    beforeEach(inject(function($controller) {
      scope = {};
      ctrl = $controller('PhoneListCtrl', {$scope:scope});
    }));

    it('should create "phones" model with 3 phones', function() {
      expect(scope.phones.length).toBe(3);
    });


    it('should set the default value of orderProp model', function() {
      expect(scope.orderProp).toBe('age');
    });
  });
});
</code></pre>

<p>The unit test now verifies that the default ordering property is set.</p>

<p>We used Jasmine&rsquo;s API to extract the controller construction into a beforeEach block, which is shared by all tests in the parent describe block.</p>

<p>You should now see the following output in the Karma tab:</p>

<pre><code>Chrome 22.0: Executed 2 of 2 SUCCESS (0.021 secs / 0.001 secs)
</code></pre>

<p>Let&rsquo;s turn our attention to the end-to-end test.</p>

<p><code>test/e2e/scenarios.js:</code></p>

<pre><code>...
it('should be possible to control phone order via the drop down select box', function() {

  var phoneNameColumn = element.all(by.repeater('phone in phones').column(''));
  var query = element(by.model('query'));

  function getNames() {
    return phoneNameColumn.map(function(elm) {
      return elm.getText();
    });
  }

  query.sendKeys('tablet'); //let's narrow the dataset to make the test assertions shorter

  expect(getNames()).toEqual([
    "Motorola XOOM\u2122 with Wi-Fi",
    "MOTOROLA XOOM\u2122"
  ]);

  element(by.model('orderProp')).findElement(by.css('option[value="name"]')).click();

  expect(getNames()).toEqual([
    "MOTOROLA XOOM\u2122",
    "Motorola XOOM\u2122 with Wi-Fi"
  ]);
});...
</code></pre>

<p>The end-to-end test verifies that the ordering mechanism of the select box is working correctly.</p>

<p>You can now rerun npm run protractor to see the tests run.</p>

<h2>Angularjs双向绑定演示</h2>

<p><a href="/phonecat/step-4/app/">Angularjs双向绑定</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/embedded/'>Embedded (5)</a></li>
<li class='category'><a href='/blog/categories/git/'>Git (2)</a></li>
<li class='category'><a href='/blog/categories/javascript/'>Javascript (16)</a></li>
<li class='category'><a href='/blog/categories/jekyll/'>Jekyll (2)</a></li>
<li class='category'><a href='/blog/categories/nodejs/'>Nodejs (2)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>Octopress (6)</a></li>
<li class='category'><a href='/blog/categories/server/'>Server (5)</a></li>
<li class='category'><a href='/blog/categories/shell/'>Shell (3)</a></li>
<li class='category'><a href='/blog/categories/sublimetext/'>SublimeText (5)</a></li>
<li class='category'><a href='/blog/categories/vim/'>Vim (3)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/05/13/install-shadowsocks-nodejs/">安装shadowsocks-nodejs</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/13/install-nodejs-in-debian/">在debian上安装nodejs</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/11/bash-shortcut/">bash快捷操作</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/08/git-settings/">常用git设置</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/08/ssh-proxy-settings/">ssh代理设置</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Tags</h1>
  <ul class="tag-cloud">
    <a style="font-size: 163%" href="/tags/angularjs/">Angularjs</a>
<a style="font-size: 185%" href="/tags/bom/">BOM</a>
<a style="font-size: 210%" href="/tags/javascript/">javascript,</a>
<a style="font-size: 122%" href="/tags/nodejs/">nodejs</a>
<a style="font-size: 122%" href="/tags/nodejs/">nodejs,</a>
<a style="font-size: 153%" href="/tags/octopress/">octopress</a>
<a style="font-size: 122%" href="/tags/octopress/">octopress,</a>
<a style="font-size: 163%" href="/tags/sublime-text/">sublime-text</a>
<a style="font-size: 140%" href="/tags/tcpip/">tcpip</a>
<a style="font-size: 140%" href="/tags/vim/">vim</a>

  </ul>
</section>
<section>
<h1>Recent Comments</h1>
<ul class="ds-recent-comments" data-num-items="10" data-show-avatars="0" data-show-time="0" data-show-title="0" data-show-admin="0" data-excerpt-length="18"></ul>

<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
  var duoshuoQuery = {short_name:"bitbegin"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->

</section><section>
<h1>友情链接</h1>
<ul>
        <li>
        <a href="http://blog.jobbole.com/">伯乐在线</a>
        </li>
        <li>
        <a href="http://www.csdn.net/">CSDN</a>
        </li>
        <li>
        <a href="http://www.cnblogs.com/">博客园</a>
        </li>
        <li>
        <a href="http://coolshell.cn/">酷壳CoolShell</a>
        </li>
</ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - dofa -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000309119'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s5.cnzz.com/z_stat.php%3Fid%3D1000309119%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>

</footer>
  











</body>
</html>
