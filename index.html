
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Do Far</title>
  <meta name="author" content="dofa">

  
  <meta name="description" content="经常使用bash，但是bash shell使用的效率一直不高，今天终于发现了有快捷键，赶快记录下来。 编辑命令 `Ctrl + a` ：移到命令行首
`Ctrl + e` ：移到命令行尾
`Ctrl + f` ：按字符前移（右向）
`Ctrl + b` ：按字符后移（左向）
`Alt + f` ： &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://blog.dofa.org">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/atom.xml" rel="alternate" title="Do Far" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-48748469-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Do Far</a></h1>
  
    <h2>There is a will, there is a way.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:blog.dofa.org" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">归档</a></li>
  <li><a href="/github">Github</a></li>
  <li><a href="/about">关于我</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/11/bash-shortcut/">bash快捷操作</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-11T09:51:30-07:00" pubdate data-updated="true">May 11<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/05/11/bash-shortcut/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><p>经常使用bash，但是bash shell使用的效率一直不高，今天终于发现了有快捷键，赶快记录下来。</p>

<h2>编辑命令</h2>

<pre><code>`Ctrl + a` ：移到命令行首
`Ctrl + e` ：移到命令行尾
`Ctrl + f` ：按字符前移（右向）
`Ctrl + b` ：按字符后移（左向）
`Alt + f` ：按单词前移（右向）
`Alt + b` ：按单词后移（左向）
`Ctrl + xx`：在命令行首和光标之间移动
`Ctrl + u` ：从光标处删除至命令行首
`Ctrl + k` ：从光标处删除至命令行尾
`Ctrl + w` ：从光标处删除至字首
`Alt + d` ：从光标处删除至字尾
`Ctrl + d` ：删除光标处的字符
`Ctrl + h` ：删除光标前的字符
`Ctrl + y` ：粘贴至光标后
`Alt + c` ：从光标处更改为首字母大写的单词
`Alt + u` ：从光标处更改为全部大写的单词
`Alt + l` ：从光标处更改为全部小写的单词
`Ctrl + t` ：交换光标处和之前的字符
`Alt + t` ：交换光标处和之前的单词
`Alt + Backspace` ：与 `Ctrl + w` 类似
</code></pre>

<h2>重新执行命令</h2>

<pre><code>`Ctrl + r` ：逆向搜索命令历史
`Ctrl + g` ：从历史搜索模式退出
`Ctrl + p` ：历史中的上一条命令
`Ctrl + n` ：历史中的下一条命令
`Alt + .` ：使用上一条命令的最后一个参数
</code></pre>

<h2>控制命令</h2>

<pre><code>`Ctrl + l` ：清屏
`Ctrl + o` ：执行当前命令，并选择上一条命令
`Ctrl + s` ：阻止屏幕输出
`Ctrl + q` ：允许屏幕输出
`Ctrl + c` ：终止命令
`Ctrl + z` ：挂起命令
</code></pre>

<h2>Bang (!) 命令</h2>

<pre><code>`!!` ：执行上一条命令
`!blah` ：执行最近的以 `blah` 开头的命令，如 `!ls`
`!blah:p` ：仅打印输出，而不执行
`!$` ：上一条命令的最后一个参数，与 `Alt + .` 相同
`!$:p` ：打印输出 `!$` 的内容
`!*` ：上一条命令的所有参数
`!*:p` ：打印输出 `!*` 的内容
`^blah` ：删除上一条命令中的 `blah`
`^blah^foo` ：将上一条命令中的 `blah` 替换为 `foo`
`^blah^foo^` ：将上一条命令中所有的 `blah` 都替换为 `foo`
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/08/git-settings/">常用git设置</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-08T13:52:50-07:00" pubdate data-updated="true">May 8<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/05/08/git-settings/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><h2>Git基本配置</h2>

<pre><code>git config --global user.name 'dofa'
git config --global user.email 'xxx@xxx.com'
</code></pre>

<h2>Git使用代理</h2>

<pre><code>git config --global http.proxy http://127.0.0.1:8087
git config --global https.proxy http://127.0.0.1:8087
git config --global http.sslverify false
</code></pre>

<p><code>http.sslverify</code>设置为<code>false</code>可以加快同步速度。</p>

<h2>Git显示漂亮日志</h2>

<pre><code>git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --"
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/08/ssh-proxy-settings/">ssh代理设置</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-08T13:28:50-07:00" pubdate data-updated="true">May 8<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/05/08/ssh-proxy-settings/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><p>有两种方式实现ssh代理，一种是ssh命令行，另外一种使用putty的plink工具。</p>

<h2>ssh命令行</h2>

<pre><code>ssh -qTfnN -D 8087 用户名@远程ssh主机名
</code></pre>

<p>上面的8087是本地未被占用的端口，可以自己选择。其它参数的意思是：</p>

<pre><code>-q :- be very quite, we are acting only as a tunnel.
-T :- Do not allocate a pseudo tty, we are only acting a tunnel.
-f :- move the ssh process to background, as we don’t want to interact with this ssh session directly.
-N :- Do not execute remote command.
-n :- redirect standard input to /dev/null. 
</code></pre>

<h4>remote端口占用</h4>

<pre><code>sudo netstat -antpl  | grep ssh
</code></pre>

<p><code>kill</code>进程</p>

<pre><code>sudo kill -9 xxxx
</code></pre>

<h2>plink工具</h2>

<pre><code>plink -C -D 127.0.0.1:8087 -N -pw 密码 用户名@远程ssh主机名 
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/26/build-angularjs-and-bootstrap-environment-with-angular-seed/">使用angular-seed搭建angularjs和bootstrap开发环境</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-26T10:36:50-07:00" pubdate data-updated="true">Apr 26<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/04/26/build-angularjs-and-bootstrap-environment-with-angular-seed/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><h2>Clone angular-seed</h2>

<pre><code>git clone https://github.com/angular/angular-seed.git
cd angular-seed
</code></pre>

<h2>Install Dependencies</h2>

<pre><code>npm install -g bower
npm install
</code></pre>

<p>如果遇到timeout问题，请设置代理：</p>

<pre><code>npm config set proxy=http://127.0.0.1:8087
</code></pre>

<h2>Run the Application</h2>

<pre><code>npm start
</code></pre>

<p>访问<code>http://localhost:8000/app/index.html</code>，看环境是否搭建ok。</p>

<h2>安装bootstrap</h2>

<p>在<code>bower.json</code>中增加<code>angular-bootstrap</code>和<code>bootstrap</code>：</p>

<pre><code>{
  "name": "angular-seed",
  "description": "A starter project for AngularJS",
  "version": "0.0.0",
  "homepage": "https://github.com/angular/angular-seed",
  "license": "MIT",
  "private": true,
  "dependencies": {
    "angular": "1.2.x",
    "angular-route": "1.2.x",
    "angular-loader": "1.2.x",
    "angular-mocks": "~1.2.15",
    "angular-bootstrap": "",
    "bootstrap": ""
  }
}
</code></pre>

<p>再执行：</p>

<pre><code>npm install
</code></pre>

<p>修改<code>app.js</code>：</p>

<pre><code>'use strict';


// Declare app level module which depends on filters, and services
angular.module('myApp', [
  'ngRoute',
  'myApp.filters',
  'myApp.services',
  'myApp.directives',
  'myApp.controllers',
  'ui.bootstrap'
]).
config(['$routeProvider', function($routeProvider) {
  $routeProvider.when('/view1', {templateUrl: 'partials/partial1.html', controller: 'MyCtrl1'});
  $routeProvider.when('/view2', {templateUrl: 'partials/partial2.html', controller: 'MyCtrl2'});
  $routeProvider.otherwise({redirectTo: '/view1'});
}]);
</code></pre>

<p>在<code>index.html</code>中增加：</p>

<pre><code>&lt;link rel="stylesheet" href="../bower_components/bootstrap/dist/css/bootstrap.css"/&gt;
</code></pre>

<p>和</p>

<pre><code>&lt;script src="../bower_components/angular-bootstrap/ui-bootstrap-tpls.js"&gt;&lt;/script&gt;
</code></pre>

<p>同样需要在<code>index-async.html</code>中增加：</p>

<pre><code>&lt;script src="../bower_components/angular-bootstrap/ui-bootstrap-tpls.js"&gt;&lt;/script&gt;
</code></pre>

<h3>Bootstrap测试</h3>

<p>使用<code>http://angular-ui.github.io/bootstrap/</code>中的测试code，进行测试，即可看到同样的UI效果。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/26/use-git-svn/">使用git-svn</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-26T07:38:50-07:00" pubdate data-updated="true">Apr 26<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/04/26/use-git-svn/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><p>个人比较习惯git，无奈目前单位使用svn，尽管svn相当不好用。今天查找了一下解决方法，本地使用git，服务器为svn类型。</p>

<h2>从svn clone出项目</h2>

<pre><code>git svn clone -s https://svn.xxx.com/svn/xxx
git svn show-ignore &gt;&gt; .git/info/exclude 
</code></pre>

<h2>建立本地工作分支</h2>

<pre><code>git checkout -b work 
</code></pre>

<p>现在可以正常使用git命令了</p>

<h2>提交回svn的过程</h2>

<pre><code>git checkout master  
git merge work  
git svn rebase  
git svn dcommit 
</code></pre>

<h2>冲突解决</h2>

<pre><code>git svn rebase 
</code></pre>

<p>提示有冲突，手动解决冲突，然后：</p>

<pre><code>git add .
git rebase --continue
git svn dcommit
</code></pre>

<p>执行后，发现本地的commit也跟server上的有同步。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/24/use-oh-my-zsh-instead-of-bash/">使用oh my zsh替代bash</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-24T14:30:50-07:00" pubdate data-updated="true">Apr 24<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/04/24/use-oh-my-zsh-instead-of-bash/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><h2>安装zsh</h2>

<pre><code>apt-get install zsh
</code></pre>

<h2>安装OH-My-ZSH</h2>

<h4>手动安装</h4>

<pre><code>cd ~
git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh

cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
</code></pre>

<p>设定为默认bash</p>

<pre><code>chsh -s /bin/zsh
</code></pre>

<h4>自动安装</h4>

<p>via <code>curl</code></p>

<pre><code>curl -L http://install.ohmyz.sh | sh
</code></pre>

<p>via <code>wget</code></p>

<pre><code>wget --no-check-certificate http://install.ohmyz.sh -O - | sh
</code></pre>

<h2>修改putty不能显示的字符</h2>

<p><code>~/.oh-my-zsh/themes/robbyrussell.zsh-theme</code></p>

<pre><code>#PROMPT='%{$fg_bold[red]%}➜ %{$fg_bold[green]%}%p %{$fg[cyan]%}%c %{$fg_bold[blue]%}$(git_prompt_info)%{$fg_bold[blue]%} % %{$reset_color%}'
PROMPT='%{$fg_bold[red]%}# %{$fg_bold[green]%}%p %{$fg[cyan]%}%c %{$fg_bold[blue]%}$(git_prompt_info)%{$fg_bold[blue]%} % %{$reset_color%}'
ZSH_THEME_GIT_PROMPT_PREFIX="git:(%{$fg[red]%}"
ZSH_THEME_GIT_PROMPT_SUFFIX="%{$reset_color%}"
#ZSH_THEME_GIT_PROMPT_DIRTY="%{$fg[blue]%}) %{$fg[yellow]%}✗%{$reset_color%}"
ZSH_THEME_GIT_PROMPT_DIRTY="%{$fg[blue]%}) %{$fg[yellow]%}X %{$reset_color%}"
ZSH_THEME_GIT_PROMPT_CLEAN="%{$fg[blue]%})"
</code></pre>

<p>使用更改后的配置：</p>

<pre><code>source `~/.oh-my-zsh/themes/robbyrussell.zsh-theme`
</code></pre>

<h2>OH-My-ZSH的使用</h2>

<ul>
<li>强大的历史纪录功能，输入 grep 然后用上下箭头可以翻阅你执行的所有 grep 命令。</li>
<li>智能拼写纠正，输入gtep mactalk * -R，系统会提示：zsh: correct ‘gtep’ to ‘grep’ [nyae]? 比妹纸贴心吧，她们向来都是让你猜的……</li>
<li>各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下 tab 键，补全项可以使用 ctrl+n/p/f/b上下左右切换。比如你想杀掉 java 的进程，只需要输入 kill java + tab键，如果只有一个 java 进程，zsh 会自动替换为进程的 pid，如果有多个则会出现选择项供你选择。ssh + 空格 + 两个tab键，zsh会列出所有访问过的主机和用户名进行补全</li>
<li>目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。</li>
<li>在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。</li>
<li>通配符搜索：ls -l <em>*/</em>.sh，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find，文件太多就歇菜了。</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/07/learning-angularjs-notes-XHRs-and-dependency-injection/">Angularjs学习笔记-XHR和依赖注入</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-07T21:55:50-07:00" pubdate data-updated="true">Apr 7<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/04/07/learning-angularjs-notes-XHRs-and-dependency-injection/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><p>到现在为止，我们使用是硬编码的三条手机记录数据集。现在我们使用AngularJS一个内置服务$http来获取一个更大的手机记录数据集。我们将使用AngularJS的依赖注入（dependency injection (DI)）功能来为PhoneListCtrl控制器提供这个AngularJS服务。</p>

<h2>数据</h2>

<p>你项目当中的<code>app/phones/phones.json</code>文件是一个数据集，它以<code>JSON</code>格式存储了一张更大的手机列表。</p>

<p>下面是这个文件的一个样例：</p>

<pre><code>[
 {
  "age": 13,
  "id": "motorola-defy-with-motoblur",
  "name": "Motorola DEFY\u2122 with MOTOBLUR\u2122",
  "snippet": "Are you ready for everything life throws your way?"
  ...
 },
...
]
</code></pre>

<h2>Controller</h2>

<p>We&rsquo;ll use Angular&rsquo;s <code>$http</code> service in our controller to make an HTTP request to your web server to fetch the data in the <code>app/phones/phones.json</code> file. <code>$http</code> is just one of several built-in <code>Angular services</code> that handle common operations in web apps. Angular injects these services for you where you need them.</p>

<p>Services are managed by Angular&rsquo;s <code>DI subsystem</code>. Dependency injection helps to make your web apps both well-structured (e.g., separate components for presentation, data, and control) and loosely coupled (dependencies between components are not resolved by the components themselves, but by the DI subsystem).</p>

<p><code>app/js/controllers.js:</code></p>

<pre><code>var phonecatApp = angular.module('phonecatApp', []);

phonecatApp.controller('PhoneListCtrl', function ($scope, $http) {
  $http.get('phones/phones.json').success(function(data) {
    $scope.phones = data;
  });

  $scope.orderProp = 'age';
});
</code></pre>

<p><code>$http</code> makes an HTTP GET request to our web server, asking for <code>phones/phones.json</code> (the url is relative to our <code>index.html</code> file). The server responds by providing the data in the json file. (The response might just as well have been dynamically generated by a backend server. To the browser and our app they both look the same. For the sake of simplicity we used a json file in this tutorial.)</p>

<p>The <code>$http</code> service returns a promise object with a success method. We call this method to handle the asynchronous response and assign the phone data to the scope controlled by this controller, as a model called phones. Notice that Angular detected the json response and parsed it for us!</p>

<p>To use a service in Angular, you simply declare the names of the dependencies you need as arguments to the controller&rsquo;s constructor function, as follows:</p>

<pre><code>phonecatApp.controller('PhoneListCtrl', function ($scope, $http) {...}
</code></pre>

<p>Angular&rsquo;s dependency injector provides services to your controller when the controller is being constructed. The dependency injector also takes care of creating any transitive dependencies the service may have (services often depend upon other services).</p>

<p>Note that the names of arguments are significant, because the injector uses these to look up the dependencies.</p>

<h2>$ Prefix Naming Convention</h2>

<p>You can create your own services, and in fact we will do exactly that in step 11. As a naming convention, Angular&rsquo;s built-in services, Scope methods and a few other Angular APIs have a <code>$</code> prefix in front of the name.</p>

<p>The <code>$</code> prefix is there to namespace Angular-provided services. To prevent collisions it&rsquo;s best to avoid naming your services and models anything that begins with a <code>$</code>.</p>

<p>If you inspect a Scope, you may also notice some properties that begin with <code>$$</code>. These properties are considered private, and should not be accessed or modified.</p>

<h2>A Note on Minification</h2>

<p>Since Angular infers the controller&rsquo;s dependencies from the names of arguments to the controller&rsquo;s constructor function, if you were to minify the JavaScript code for PhoneListCtrl controller, all of its function arguments would be minified as well, and the dependency injector would not be able to identify services correctly.</p>

<p>We can overcome this problem by annotating the function with the names of the dependencies, provided as strings, which will not get minified. There are two ways to provide these injection annotations:</p>

<ul>
<li>Create a <code>$inject</code> property on the controller function which holds an array of strings. Each string in the array is the name of the service to inject for the corresponding parameter. In our example we would write:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function PhoneListCtrl($scope, $http) {...}
</span><span class='line'>PhoneListCtrl.$inject = ['$scope', '$http'];
</span><span class='line'>phonecatApp.controller('PhoneListCtrl', PhoneListCtrl);</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Use an inline annotation where, instead of just providing the function, you provide an array. This array contains a list of the service names, followed by the function itself.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function PhoneListCtrl($scope, $http) {...}
</span><span class='line'>phonecatApp.controller('PhoneListCtrl', ['$scope', '$http', PhoneListCtrl]);</span></code></pre></td></tr></table></div></figure>


<p>Both of these methods work with any function that can be injected by Angular, so it&rsquo;s up to your project&rsquo;s style guide to decide which one you use.</p>

<p>When using the second method, it is common to provide the constructor function inline as an anonymous function when registering the controller:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>phonecatApp.controller('PhoneListCtrl', ['$scope', '$http', function($scope, $http) {...}]);</span></code></pre></td></tr></table></div></figure>


<p>From this point onward, we&rsquo;re going to use the inline method in the tutorial. With that in mind, let&rsquo;s add the annotations to our PhoneListCtrl:</p>

<p><code>app/js/controllers.js:</code></p>

<pre><code>var phonecatApp = angular.module('phonecatApp', []);

phonecatApp.controller('PhoneListCtrl', ['$scope', '$http',
  function ($scope, $http) {
    $http.get('phones/phones.json').success(function(data) {
      $scope.phones = data;
    });

    $scope.orderProp = 'age';
  }]);
</code></pre>

<h2>Test</h2>

<p><code>test/unit/controllersSpec.js:</code></p>

<p>Because we started using dependency injection and our controller has dependencies, constructing the controller in our tests is a bit more complicated. We could use the new operator and provide the constructor with some kind of fake $http implementation. However, Angular provides a mock $http service that we can use in unit tests. We configure &ldquo;fake&rdquo; responses to server requests by calling methods on a service called $httpBackend:</p>

<pre><code>describe('PhoneCat controllers', function() {

  describe('PhoneListCtrl', function(){
    var scope, ctrl, $httpBackend;

    // Load our app module definition before each test.
    beforeEach(module('phonecatApp'));

    // The injector ignores leading and trailing underscores here (i.e. _$httpBackend_).
    // This allows us to inject a service but then attach it to a variable
    // with the same name as the service.
    beforeEach(inject(function(_$httpBackend_, $rootScope, $controller) {
      $httpBackend = _$httpBackend_;
      $httpBackend.expectGET('phones/phones.json').
          respond([{name: 'Nexus S'}, {name: 'Motorola DROID'}]);

      scope = $rootScope.$new();
      ctrl = $controller('PhoneListCtrl', {$scope: scope});
    }));
</code></pre>

<p>Note: Because we loaded Jasmine and angular-mocks.js in our test environment, we got two helper methods module and inject that we&rsquo;ll use to access and configure the injector.</p>

<p>We created the controller in the test environment, as follows:</p>

<ul>
<li><p>We used the inject helper method to inject instances of <code>$rootScope</code>, <code>$controller</code> and <code>$httpBackend</code> services into the Jasmine&rsquo;s beforeEach function. These instances come from an injector which is recreated from scratch for every single test. This guarantees that each test starts from a well known starting point and each test is isolated from the work done in other tests.</p></li>
<li><p>We created a new scope for our controller by calling <code>$rootScope.$new()</code></p></li>
<li><p>We called the injected <code>$controller</code> function passing the name of the <code>PhoneListCtrl</code> controller and the created scope as parameters.</p></li>
</ul>


<p>Because our code now uses the $http service to fetch the phone list data in our controller, before we create the PhoneListCtrl child scope, we need to tell the testing harness to expect an incoming request from the controller. To do this we:</p>

<ul>
<li><p>Request <code>$httpBackend</code> service to be injected into our beforeEach function. This is a mock version of the service that in a production environment facilitates all XHR and JSONP requests. The mock version of this service allows you to write tests without having to deal with native APIs and the global state associated with them — both of which make testing a nightmare.</p></li>
<li><p>Use the <code>$httpBackend.expectGET</code> method to train the $httpBackend service to expect an incoming HTTP request and tell it what to respond with. Note that the responses are not returned until we call the $httpBackend.flush method.</p></li>
</ul>


<p>Now we will make assertions to verify that the phones model doesn&rsquo;t exist on scope before the response is received:</p>

<pre><code>it('should create "phones" model with 2 phones fetched from xhr', function() {
  expect(scope.phones).toBeUndefined();
  $httpBackend.flush();

  expect(scope.phones).toEqual([{name: 'Nexus S'},
                               {name: 'Motorola DROID'}]);
});
</code></pre>

<ul>
<li><p>We flush the request queue in the browser by calling <code>$httpBackend.flush()</code>. This causes the promise returned by the $http service to be resolved with the trained response.</p></li>
<li><p>We make the assertions, verifying that the phone model now exists on the scope.</p></li>
</ul>


<p>Finally, we verify that the default value of orderProp is set correctly:</p>

<pre><code>it('should set the default value of orderProp model', function() {
  expect(scope.orderProp).toBe('age');
});
</code></pre>

<p>You should now see the following output in the Karma tab:</p>

<pre><code>Chrome 22.0: Executed 2 of 2 SUCCESS (0.028 secs / 0.007 secs)
</code></pre>

<h2>AngularjsXHR和依赖注入演示</h2>

<p><a href="/phonecat/step-5/app/">AngularjsXHR和依赖注入</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/07/learning-angularjs-notes-two-way-data-bingding/">Angularjs学习笔记-双向绑定</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-07T21:11:50-07:00" pubdate data-updated="true">Apr 7<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/04/07/learning-angularjs-notes-two-way-data-bingding/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><p>动态排序可以这样实现，添加一个新的模型属性，把它和迭代器集成起来，然后让数据绑定完成剩下的事情。</p>

<h2>模板</h2>

<p><code>app/index.html:</code></p>

<pre><code>Search: &lt;input ng-model="query"&gt;
Sort by:
&lt;select ng-model="orderProp"&gt;
    &lt;option value="name"&gt;Alphabetical&lt;/option&gt;
    &lt;option value="age"&gt;Newest&lt;/option&gt;
&lt;/select&gt;


&lt;ul class="phones"&gt;
    &lt;li ng-repeat="phone in phones | filter:query | orderBy:orderProp"&gt;

        &lt;p&gt;&lt;/p&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>我们在<code>index.html</code>中做了如下更改：</p>

<ul>
<li><p>首先，我们增加了一个叫做<code>orderProp</code>的<code>&lt;select&gt;</code>标签，这样我们的用户就可以选择我们提供的两种排序方法。</p></li>
<li><p>然后，在<code>filter</code>过滤器后面添加一个<code>orderBy</code>过滤器用其来处理进入迭代器的数据。<code>orderBy</code>过滤器以一个数组作为输入，复制一份副本，然后把副本重排序再输出到迭代器。</p></li>
</ul>


<p><code>AngularJS</code>在<code>select</code>元素和<code>orderProp</code>模型之间创建了一个双向绑定。而后，<code>orderProp</code>会被用作<code>orderBy</code>过滤器的输入。</p>

<p>正如我们在步骤3中讨论数据绑定和迭代器的时候所说的一样，无论什么时候数据模型发生了改变（比如用户在下拉菜单中选了不同的顺序），AngularJS的数据绑定会让视图自动更新。没有任何笨拙的DOM操作！</p>

<h2>控制器</h2>

<p><code>app/js/controllers.js:</code></p>

<pre><code>var phonecatApp = angular.module('phonecatApp', []);

phonecatApp.controller('PhoneListCtrl', function ($scope) {
  $scope.phones = [
    {'name': 'Nexus S',
     'snippet': 'Fast just got faster with Nexus S.',
     'age': 1},
    {'name': 'Motorola XOOM™ with Wi-Fi',
     'snippet': 'The Next, Next Generation tablet.',
     'age': 2},
    {'name': 'MOTOROLA XOOM™',
     'snippet': 'The Next, Next Generation tablet.',
     'age': 3}
  ];

  $scope.orderProp = 'age';
});
</code></pre>

<ul>
<li>我们修改了<code>phones</code>模型—— 手机的数组 ——为每一个手机记录其增加了一个<code>age</code>属性。我们会根据<code>age</code>属性来对手机进行排序。</li>
<li>我们在控制器代码里加了一行让<code>orderProp</code>的默认值为<code>age</code>。如果我们不设置默认值，这个模型会在我们的用户在下拉菜单选择一个顺序之前一直处于未初始化状态。</li>
</ul>


<p>现在我们该好好谈谈双向数据绑定了。注意到当应用在浏览器中加载时，“Newest”在下拉菜单中被选中。这是因为我们在控制器中把<code>orderProp</code>设置成了‘age’。所以绑定在从我们模型到用户界面的方向上起作用——即数据从模型到视图的绑定。现在当你在下拉菜单中选择“Alphabetically”，数据模型会被同时更新，并且手机列表数组会被重新排序。这个时候数据绑定从另一个方向产生了作用——即数据从视图到模型的绑定。</p>

<h2>Test</h2>

<p>The changes we made should be verified with both a unit test and an end-to-end test. Let&rsquo;s look at the unit test first.</p>

<p><code>test/unit/controllersSpec.js:</code></p>

<pre><code>describe('PhoneCat controllers', function() {

  describe('PhoneListCtrl', function(){
    var scope, ctrl;

    beforeEach(module('phonecatApp'));

    beforeEach(inject(function($controller) {
      scope = {};
      ctrl = $controller('PhoneListCtrl', {$scope:scope});
    }));

    it('should create "phones" model with 3 phones', function() {
      expect(scope.phones.length).toBe(3);
    });


    it('should set the default value of orderProp model', function() {
      expect(scope.orderProp).toBe('age');
    });
  });
});
</code></pre>

<p>The unit test now verifies that the default ordering property is set.</p>

<p>We used Jasmine&rsquo;s API to extract the controller construction into a beforeEach block, which is shared by all tests in the parent describe block.</p>

<p>You should now see the following output in the Karma tab:</p>

<pre><code>Chrome 22.0: Executed 2 of 2 SUCCESS (0.021 secs / 0.001 secs)
</code></pre>

<p>Let&rsquo;s turn our attention to the end-to-end test.</p>

<p><code>test/e2e/scenarios.js:</code></p>

<pre><code>...
it('should be possible to control phone order via the drop down select box', function() {

  var phoneNameColumn = element.all(by.repeater('phone in phones').column(''));
  var query = element(by.model('query'));

  function getNames() {
    return phoneNameColumn.map(function(elm) {
      return elm.getText();
    });
  }

  query.sendKeys('tablet'); //let's narrow the dataset to make the test assertions shorter

  expect(getNames()).toEqual([
    "Motorola XOOM\u2122 with Wi-Fi",
    "MOTOROLA XOOM\u2122"
  ]);

  element(by.model('orderProp')).findElement(by.css('option[value="name"]')).click();

  expect(getNames()).toEqual([
    "MOTOROLA XOOM\u2122",
    "Motorola XOOM\u2122 with Wi-Fi"
  ]);
});...
</code></pre>

<p>The end-to-end test verifies that the ordering mechanism of the select box is working correctly.</p>

<p>You can now rerun npm run protractor to see the tests run.</p>

<h2>Angularjs双向绑定演示</h2>

<p><a href="/phonecat/step-4/app/">Angularjs双向绑定</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/07/learning-angularjs-notes-filtering-repeaters/">Angularjs学习笔记-迭代器过滤</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-07T20:56:50-07:00" pubdate data-updated="true">Apr 7<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/04/07/learning-angularjs-notes-filtering-repeaters/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><p>使用AngularJS的迭代器过滤功能可以方便的对数据进行过滤。</p>

<h2>控制器</h2>

<p>我们对控制器不做任何修改。</p>

<h2>模板</h2>

<p><code>app/index.html</code>:</p>

<p>  <div class="container-fluid"></p>

<pre><code>&lt;div class="row-fluid"&gt;
  &lt;div class="span2"&gt;
    &lt;!--Sidebar content--&gt;

    Search: &lt;input ng-model="query"&gt;

  &lt;/div&gt;
  &lt;div class="span10"&gt;
    &lt;!--Body content--&gt;

    &lt;ul class="phones"&gt;
      &lt;li ng-repeat="phone in phones | filter:query"&gt;

        &lt;p&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

  &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>  </div></p>

<p>我们现在添加了一个<code>&lt;input&gt;</code>标签，并且使用<code>AngularJS</code>的<code>$filter</code>函数来处理<code>ngRepeat</code>指令的输入。</p>

<p>这样允许用户输入一个搜索条件，立刻就能看到对电话列表的搜索结果。我们来解释一下新的代码：</p>

<ul>
<li><p>数据绑定： 这是<code>AngularJS</code>的一个核心特性。当页面加载的时候，<code>AngularJS</code>会根据输入框的属性值名字，将其与数据模型中相同名字的变量绑定在一起，以确保两者的同步性。</p></li>
<li><p>在这段代码中，用户在输入框中输入的数据名字称作<code>query</code>，会立刻作为列表迭代器（<code>phone in phones | filter:query</code>）其过滤器的输入。当数据模型引起迭代器输入变化的时候，迭代器可以高效得更新DOM将数据模型最新的状态反映出来。</p></li>
<li><p>使用<code>filter</code>过滤器：<code>filter</code>函数使用<code>query</code>的值来创建一个只包含匹配<code>query</code>记录的新数组。</p></li>
<li><p><code>ngRepeat</code>会根据<code>filter</code>过滤器生成的手机记录数据数组来自动更新视图。整个过程对于开发者来说都是透明的。</p></li>
</ul>


<h2>测试</h2>

<p>在步骤2，我们学习了编写和运行一个测试的方法。单元测试用来测试我们用js编写的控制器和其他组件都非常方便，但是不能方便的对DOM操作和应用集成进行测试。对于这些来说，端到端测试是一个更好的选择。</p>

<p>搜索特性是完全通过模板和数据绑定实现的，所以我们的第一个端到端测试就来验证这些特性是否符合我们的预期。</p>

<p><code>test/e2e/scenarios.js:</code></p>

<pre><code>describe('PhoneCat App', function() {

  describe('Phone list view', function() {

    beforeEach(function() {
      browser.get('app/index.html');
    });


    it('should filter the phone list as user types into the search box', function() {

      var phoneList = element.all(by.repeater('phone in phones'));
      var query = element(by.model('query'));

      expect(phoneList.count()).toBe(3);

      query.sendKeys('nexus');
      expect(phoneList.count()).toBe(1);

      query.clear();
      query.sendKeys('motorola');
      expect(phoneList.count()).toBe(2);
    });
  });
});
</code></pre>

<p>This test verifies that the search box and the repeater are correctly wired together. Notice how easy it is to write end-to-end tests in Angular. Although this example is for a simple test, it really is that easy to set up any functional, readable, end-to-end test.</p>

<h2>Running End to End Tests with Protractor</h2>

<p>Even though the syntax of this test looks very much like our controller unit test written with <code>Jasmine</code>, the end-to-end test uses APIs of Protractor. Read about the Protractor APIs at <code>https://github.com/angular/protractor/blob/master/docs/api.md</code>.</p>

<p>Much like <code>Karma</code> is the test runner for unit tests, we use Protractor to run end-to-end tests. Try it with npm run protractor. End-to-end tests are slow, so unlike with unit tests, Protractor will exit after the test run and will not automatically rerun the test suite on every file change. To rerun the test suite, execute npm run protractor again.</p>

<pre><code>Note: You must ensure you've installed the protractor and updated webdriver prior to running the npm run protractor. You can do this by issuing npm install and npm run update-webdriver into your terminal.
</code></pre>

<h2>Angularjs迭代器过滤演示</h2>

<p><a href="/phonecat/step-3/app/">Angularjs迭代器过滤</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/07/learning-angularjs-notes-dynamic-templates/">Angularjs学习笔记-动态模板</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-07T16:10:10-07:00" pubdate data-updated="true">Apr 7<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/04/07/learning-angularjs-notes-dynamic-templates/#comments">Comments</a>
                
      </p>
    
  </header>


  <div class="entry-content"><p>AngularJS应用使用模型-视图-控制器（MVC）模式解耦代码和分离关注点。</p>

<h2>视图和模板</h2>

<p>在<code>AngularJS</code>中，一个视图是模型通过HTML<strong>模板</strong>渲染之后的映射。这意味着，不论模型什么时候发生变化，<code>AngularJS</code>会实时更新结合点，随之更新视图。</p>

<p>视图组件被AngularJS用下面这个模板构建出来:</p>

<p><code>app/index.html</code>:</p>

<pre><code>&lt;html ng-app="phonecatApp"&gt;
&lt;head&gt;
  ...
  &lt;script src="../bower_components/angular/angular.js"&gt;&lt;/script&gt;
  &lt;script src="js/controllers.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body ng-controller="PhoneListCtrl"&gt;

  &lt;ul&gt;
    &lt;li ng-repeat="phone in phones"&gt;

      &lt;p&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>我们刚刚把静态编码的手机列表替换掉了，因为这里我们使用<code>ngRepeat</code>指令和两个用花括号包裹起来的<code>AngularJS</code>表达式——<code>{{phone.name}}</code>
和<code>{{phone.snippet}}</code>——能达到同样的效果。</p>

<p>在<code>&lt;li&gt;</code>标签里面的<code>ng-repeat="phone in phones"</code>语句是一个<code>AngularJS</code>迭代器。这个迭代器告诉<code>AngularJS</code>用第一个<code>&lt;li&gt;</code>标签作为模板为列表中的每一部手机创建一个<code>&lt;li&gt;</code>元素。
正如我们在第0步时学到的，包裹在<code>phone.name</code>和<code>phone.snippet</code>周围的花括号标识着数据绑定。和常量计算不同的是，这里的表达式实际上是我们应用的一个数据模型引用，这些我们在<code>PhoneListCtrl</code>控制器里面都设置好了。</p>

<h2>模型和控制器</h2>

<p>在<code>PhoneListCtrl</code>控制器里面初始化了数据模型（这里只不过是一个包含了数组的函数，数组中存储的对象是手机数据列表）：</p>

<p><code>app/js/controller.js:</code></p>

<pre><code>var phonecatApp = angular.module('phonecatApp', []);

phonecatApp.controller('PhoneListCtrl', function ($scope) {
  $scope.phones = [
    {'name': 'Nexus S',
     'snippet': 'Fast just got faster with Nexus S.'},
    {'name': 'Motorola XOOM™ with Wi-Fi',
     'snippet': 'The Next, Next Generation tablet.'},
    {'name': 'MOTOROLA XOOM™',
     'snippet': 'The Next, Next Generation tablet.'}
  ];
});
</code></pre>

<p>尽管控制器看起来并没有起到什么控制的作用，但是它在这里起到了至关重要的作用。通过给定我们数据模型的语境，控制器允许我们建立模型和视图之间的数据绑定。我们是这样把表现层，数据和逻辑部件联系在一起的：</p>

<ul>
<li><code>PhoneListCtrl</code>——控制器方法的名字（在JS文件<code>controllers.js</code>中）和<code>&lt;body&gt;</code>标签里面的<code>ngController</code>指令的值相匹配。</li>
<li>手机的数据此时与注入到我们控制器函数的作用域（<code>$scope</code>）相关联。当应用启动之后，会有一个根作用域被创建出来，而控制器的作用域是根作用域的一个典型后继。这个控制器的作用域对所有<code>&lt;body ng-controller="PhoneListCtrl"&gt;</code>标记内部的数据绑定有效。</li>
</ul>


<p><code>AngularJS</code>的作用域理论非常重要：一个作用域可以视作模板、模型和控制器协同工作的粘接器。<code>AngularJS</code>使用作用域，同时还有模板中的信息，数据模型和控制器。这些可以帮助模型和视图分离，但是他们两者确实是同步的！任何对于模型的更改都会即时反映在视图上；任何在视图上的更改都会被立刻体现在模型中。</p>

<h2>测试</h2>

<p>“AngularJS方式”让开发时代码测试变得十分简单。让我们来瞅一眼下面这个为控制器新添加的单元测试：</p>

<p><code>test/unit/controllersSpec.js:</code></p>

<pre><code>describe('PhoneCat controllers', function() {

  describe('PhoneListCtrl', function(){

    it('should create "phones" model with 3 phones', function() {
      var scope = {},
      ctrl = new PhoneListCtrl(scope);

      expect(scope.phones.length).toBe(3);
    });
  });
});
</code></pre>

<p>The test instantiates <code>PhoneListCtrl</code> and verifies that the phones array property on the scope contains three records. This example demonstrates how easy it is to create a unit test for code in Angular. Since testing is such a critical part of software development, we make it easy to create tests in Angular so that developers are encouraged to write them.</p>

<p>Note: 进入下一步之前要安装<code>karma</code></p>

<pre><code>npm install -g karma
</code></pre>

<p>出现问题试试下面的命令：</p>

<pre><code>npm install -g karma-cli

npm install -g zeparser

npm install npm -g

npm config set strict-ssl false
</code></pre>

<p>另外注意看<code>debug.log</code>查看缺失的包，然后安装上去</p>

<h2>Testing non-Global Controllers</h2>

<p>In practice, you will not want to have your controller functions in the global namespace. Instead, you can see that we have registered it via an anonymous constructor function on the <code>phoneCatApp</code> module.</p>

<p>In this case Angular provides a service, <code>$controller</code>, which will retrieve your controller by name. Here is the same test using <code>$controller</code>:</p>

<p><code>test/unit/controllersSpec.js:</code></p>

<pre><code>describe('PhoneListCtrl', function(){

  beforeEach(module('phonecatApp'));

  it('should create "phones" model with 3 phones', inject(function($controller) {
    var scope = {},
        ctrl = $controller('PhoneListCtrl', {$scope:scope});

    expect(scope.phones.length).toBe(3);
  }));

});
</code></pre>

<ul>
<li>Before each test we tell Angular to load the <code>phonecatApp</code> module.</li>
<li>We ask Angular to inject the <code>$controller</code> service into our test function</li>
<li>We use <code>$controller</code> to create an instance of the <code>PhoneListCtrl</code></li>
<li>With this instance, we verify that the phones array property on the scope contains three records.</li>
</ul>


<h2>Writing and Running Tests</h2>

<p>Angular developers prefer the syntax of Jasmine&rsquo;s Behavior-driven Development (BDD) framework when writing tests. Although Angular does not require you to use Jasmine, we wrote all of the tests in this tutorial in Jasmine v1.3. You can learn about Jasmine on the Jasmine home page and at the Jasmine docs.</p>

<p>The angular-seed project is pre-configured to run unit tests using Karma but you will need to ensure that Karma and its necessary plugins are installed. You can do this by running npm install.</p>

<p>To run the tests, and then watch the files for changes: npm test.</p>

<ul>
<li>Karma will start a new instance of Chrome browser automatically. Just ignore it and let it run in the background. Karma will use this browser for test execution.</li>
<li><p>You should see the following or similar output in the terminal:</p>

<p>  info: Karma server started at <a href="http://localhost:9876/">http://localhost:9876/</a>
  info (launcher): Starting  browser &ldquo;Chrome&rdquo;
  info (Chrome 22.0): Connected on socket id tPUm9DXcLHtZTKbAEO-n
  Chrome 22.0: Executed 1 of 1 SUCCESS (0.093 secs / 0.004 secs)</p></li>
</ul>


<p>Yay! The test passed! Or not&hellip;</p>

<ul>
<li>To rerun the tests, just change any of the source or test .js files. Karma will notice the change and will rerun the tests for you. Now isn&rsquo;t that sweet?</li>
</ul>


<h2>Angularjs动态模板演示</h2>

<p><a href="/phonecat/step-2/app/">Angularjs动态模板</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/embedded/'>Embedded (5)</a></li>
<li class='category'><a href='/blog/categories/git/'>Git (2)</a></li>
<li class='category'><a href='/blog/categories/javascript/'>Javascript (16)</a></li>
<li class='category'><a href='/blog/categories/jekyll/'>Jekyll (2)</a></li>
<li class='category'><a href='/blog/categories/nodejs/'>Nodejs (2)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>Octopress (6)</a></li>
<li class='category'><a href='/blog/categories/server/'>Server (3)</a></li>
<li class='category'><a href='/blog/categories/shell/'>Shell (3)</a></li>
<li class='category'><a href='/blog/categories/sublimetext/'>SublimeText (5)</a></li>
<li class='category'><a href='/blog/categories/vim/'>Vim (3)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/05/11/bash-shortcut/">bash快捷操作</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/08/git-settings/">常用git设置</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/08/ssh-proxy-settings/">ssh代理设置</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/26/build-angularjs-and-bootstrap-environment-with-angular-seed/">使用angular-seed搭建angularjs和bootstrap开发环境</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/26/use-git-svn/">使用git-svn</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Tags</h1>
  <ul class="tag-cloud">
    <a style="font-size: 163%" href="/tags/angularjs/">Angularjs</a>
<a style="font-size: 185%" href="/tags/bom/">BOM</a>
<a style="font-size: 90%" href="/tags/task/">Task</a>
<a style="font-size: 90%" href="/tags/github/">github,</a>
<a style="font-size: 210%" href="/tags/javascript/">javascript,</a>
<a style="font-size: 153%" href="/tags/octopress/">octopress</a>
<a style="font-size: 122%" href="/tags/octopress/">octopress,</a>
<a style="font-size: 163%" href="/tags/sublime-text/">sublime-text</a>
<a style="font-size: 140%" href="/tags/tcpip/">tcpip</a>
<a style="font-size: 140%" href="/tags/vim/">vim</a>

  </ul>
</section>
<section>
<h1>Recent Comments</h1>
<ul class="ds-recent-comments" data-num-items="10" data-show-avatars="0" data-show-time="0" data-show-title="0" data-show-admin="0" data-excerpt-length="18"></ul>

<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
  var duoshuoQuery = {short_name:"bitbegin"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->

</section><section>
<h1>友情链接</h1>
<ul>
        <li>
        <a href="http://blog.jobbole.com/">伯乐在线</a>
        </li>
        <li>
        <a href="http://www.csdn.net/">CSDN</a>
        </li>
        <li>
        <a href="http://www.cnblogs.com/">博客园</a>
        </li>
        <li>
        <a href="http://coolshell.cn/">酷壳CoolShell</a>
        </li>
</ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - dofa -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000309119'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s5.cnzz.com/z_stat.php%3Fid%3D1000309119%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>

</footer>
  











</body>
</html>
