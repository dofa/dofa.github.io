<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | Do Far]]></title>
  <link href="http://blog.dofa.org/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://blog.dofa.org/"/>
  <updated>2014-04-07T06:22:50-07:00</updated>
  <id>http://blog.dofa.org/</id>
  <author>
    <name><![CDATA[dofa]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Angularjs学习笔记-双向绑定]]></title>
    <link href="http://blog.dofa.org/blog/2014/04/07/learning-angularjs-notes-two-way-data-bingding/"/>
    <updated>2014-04-07T21:11:50-07:00</updated>
    <id>http://blog.dofa.org/blog/2014/04/07/learning-angularjs-notes-two-way-data-bingding</id>
    <content type="html"><![CDATA[<p>动态排序可以这样实现，添加一个新的模型属性，把它和迭代器集成起来，然后让数据绑定完成剩下的事情。</p>

<h2>模板</h2>

<p><code>app/index.html:</code></p>

<pre><code>Search: &lt;input ng-model="query"&gt;
Sort by:
&lt;select ng-model="orderProp"&gt;
    &lt;option value="name"&gt;Alphabetical&lt;/option&gt;
    &lt;option value="age"&gt;Newest&lt;/option&gt;
&lt;/select&gt;


&lt;ul class="phones"&gt;
    &lt;li ng-repeat="phone in phones | filter:query | orderBy:orderProp"&gt;
        
        &lt;p&gt;&lt;/p&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>我们在<code>index.html</code>中做了如下更改：</p>

<ul>
<li><p>首先，我们增加了一个叫做<code>orderProp</code>的<code>&lt;select&gt;</code>标签，这样我们的用户就可以选择我们提供的两种排序方法。</p></li>
<li><p>然后，在<code>filter</code>过滤器后面添加一个<code>orderBy</code>过滤器用其来处理进入迭代器的数据。<code>orderBy</code>过滤器以一个数组作为输入，复制一份副本，然后把副本重排序再输出到迭代器。</p></li>
</ul>


<p><code>AngularJS</code>在<code>select</code>元素和<code>orderProp</code>模型之间创建了一个双向绑定。而后，<code>orderProp</code>会被用作<code>orderBy</code>过滤器的输入。</p>

<p>正如我们在步骤3中讨论数据绑定和迭代器的时候所说的一样，无论什么时候数据模型发生了改变（比如用户在下拉菜单中选了不同的顺序），AngularJS的数据绑定会让视图自动更新。没有任何笨拙的DOM操作！</p>

<h2>控制器</h2>

<p><code>app/js/controllers.js:</code></p>

<pre><code>var phonecatApp = angular.module('phonecatApp', []);

phonecatApp.controller('PhoneListCtrl', function ($scope) {
  $scope.phones = [
    {'name': 'Nexus S',
     'snippet': 'Fast just got faster with Nexus S.',
     'age': 1},
    {'name': 'Motorola XOOM™ with Wi-Fi',
     'snippet': 'The Next, Next Generation tablet.',
     'age': 2},
    {'name': 'MOTOROLA XOOM™',
     'snippet': 'The Next, Next Generation tablet.',
     'age': 3}
  ];

  $scope.orderProp = 'age';
});
</code></pre>

<ul>
<li>我们修改了<code>phones</code>模型—— 手机的数组 ——为每一个手机记录其增加了一个<code>age</code>属性。我们会根据<code>age</code>属性来对手机进行排序。</li>
<li>我们在控制器代码里加了一行让<code>orderProp</code>的默认值为<code>age</code>。如果我们不设置默认值，这个模型会在我们的用户在下拉菜单选择一个顺序之前一直处于未初始化状态。</li>
</ul>


<p>现在我们该好好谈谈双向数据绑定了。注意到当应用在浏览器中加载时，“Newest”在下拉菜单中被选中。这是因为我们在控制器中把<code>orderProp</code>设置成了‘age’。所以绑定在从我们模型到用户界面的方向上起作用——即数据从模型到视图的绑定。现在当你在下拉菜单中选择“Alphabetically”，数据模型会被同时更新，并且手机列表数组会被重新排序。这个时候数据绑定从另一个方向产生了作用——即数据从视图到模型的绑定。</p>

<h2>Test</h2>

<p>The changes we made should be verified with both a unit test and an end-to-end test. Let&rsquo;s look at the unit test first.</p>

<p><code>test/unit/controllersSpec.js:</code></p>

<pre><code>describe('PhoneCat controllers', function() {

  describe('PhoneListCtrl', function(){
    var scope, ctrl;

    beforeEach(module('phonecatApp'));

    beforeEach(inject(function($controller) {
      scope = {};
      ctrl = $controller('PhoneListCtrl', {$scope:scope});
    }));

    it('should create "phones" model with 3 phones', function() {
      expect(scope.phones.length).toBe(3);
    });


    it('should set the default value of orderProp model', function() {
      expect(scope.orderProp).toBe('age');
    });
  });
});
</code></pre>

<p>The unit test now verifies that the default ordering property is set.</p>

<p>We used Jasmine&rsquo;s API to extract the controller construction into a beforeEach block, which is shared by all tests in the parent describe block.</p>

<p>You should now see the following output in the Karma tab:</p>

<pre><code>Chrome 22.0: Executed 2 of 2 SUCCESS (0.021 secs / 0.001 secs)
</code></pre>

<p>Let&rsquo;s turn our attention to the end-to-end test.</p>

<p><code>test/e2e/scenarios.js:</code></p>

<pre><code>...
it('should be possible to control phone order via the drop down select box', function() {

  var phoneNameColumn = element.all(by.repeater('phone in phones').column(''));
  var query = element(by.model('query'));

  function getNames() {
    return phoneNameColumn.map(function(elm) {
      return elm.getText();
    });
  }

  query.sendKeys('tablet'); //let's narrow the dataset to make the test assertions shorter

  expect(getNames()).toEqual([
    "Motorola XOOM\u2122 with Wi-Fi",
    "MOTOROLA XOOM\u2122"
  ]);

  element(by.model('orderProp')).findElement(by.css('option[value="name"]')).click();

  expect(getNames()).toEqual([
    "MOTOROLA XOOM\u2122",
    "Motorola XOOM\u2122 with Wi-Fi"
  ]);
});...
</code></pre>

<p>The end-to-end test verifies that the ordering mechanism of the select box is working correctly.</p>

<p>You can now rerun npm run protractor to see the tests run.</p>

<h2>Angularjs双向绑定演示</h2>

<p><a href="/phonecat/step-4/app/">Angularjs双向绑定</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angularjs学习笔记-迭代器过滤]]></title>
    <link href="http://blog.dofa.org/blog/2014/04/07/learning-angularjs-notes-filtering-repeaters/"/>
    <updated>2014-04-07T20:56:50-07:00</updated>
    <id>http://blog.dofa.org/blog/2014/04/07/learning-angularjs-notes-filtering-repeaters</id>
    <content type="html"><![CDATA[<p>使用AngularJS的迭代器过滤功能可以方便的对数据进行过滤。</p>

<h2>控制器</h2>

<p>我们对控制器不做任何修改。</p>

<h2>模板</h2>

<p><code>app/index.html</code>:</p>

<p>  <div class="container-fluid"></p>

<pre><code>&lt;div class="row-fluid"&gt;
  &lt;div class="span2"&gt;
    &lt;!--Sidebar content--&gt;

    Search: &lt;input ng-model="query"&gt;

  &lt;/div&gt;
  &lt;div class="span10"&gt;
    &lt;!--Body content--&gt;

    &lt;ul class="phones"&gt;
      &lt;li ng-repeat="phone in phones | filter:query"&gt;
        
        &lt;p&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

  &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>  </div></p>

<p>我们现在添加了一个<code>&lt;input&gt;</code>标签，并且使用<code>AngularJS</code>的<code>$filter</code>函数来处理<code>ngRepeat</code>指令的输入。</p>

<p>这样允许用户输入一个搜索条件，立刻就能看到对电话列表的搜索结果。我们来解释一下新的代码：</p>

<ul>
<li><p>数据绑定： 这是<code>AngularJS</code>的一个核心特性。当页面加载的时候，<code>AngularJS</code>会根据输入框的属性值名字，将其与数据模型中相同名字的变量绑定在一起，以确保两者的同步性。</p></li>
<li><p>在这段代码中，用户在输入框中输入的数据名字称作<code>query</code>，会立刻作为列表迭代器（<code>phone in phones | filter:query</code>）其过滤器的输入。当数据模型引起迭代器输入变化的时候，迭代器可以高效得更新DOM将数据模型最新的状态反映出来。</p></li>
<li><p>使用<code>filter</code>过滤器：<code>filter</code>函数使用<code>query</code>的值来创建一个只包含匹配<code>query</code>记录的新数组。</p></li>
<li><p><code>ngRepeat</code>会根据<code>filter</code>过滤器生成的手机记录数据数组来自动更新视图。整个过程对于开发者来说都是透明的。</p></li>
</ul>


<h2>测试</h2>

<p>在步骤2，我们学习了编写和运行一个测试的方法。单元测试用来测试我们用js编写的控制器和其他组件都非常方便，但是不能方便的对DOM操作和应用集成进行测试。对于这些来说，端到端测试是一个更好的选择。</p>

<p>搜索特性是完全通过模板和数据绑定实现的，所以我们的第一个端到端测试就来验证这些特性是否符合我们的预期。</p>

<p><code>test/e2e/scenarios.js:</code></p>

<pre><code>describe('PhoneCat App', function() {

  describe('Phone list view', function() {

    beforeEach(function() {
      browser.get('app/index.html');
    });


    it('should filter the phone list as user types into the search box', function() {

      var phoneList = element.all(by.repeater('phone in phones'));
      var query = element(by.model('query'));

      expect(phoneList.count()).toBe(3);

      query.sendKeys('nexus');
      expect(phoneList.count()).toBe(1);

      query.clear();
      query.sendKeys('motorola');
      expect(phoneList.count()).toBe(2);
    });
  });
});
</code></pre>

<p>This test verifies that the search box and the repeater are correctly wired together. Notice how easy it is to write end-to-end tests in Angular. Although this example is for a simple test, it really is that easy to set up any functional, readable, end-to-end test.</p>

<h2>Running End to End Tests with Protractor</h2>

<p>Even though the syntax of this test looks very much like our controller unit test written with <code>Jasmine</code>, the end-to-end test uses APIs of Protractor. Read about the Protractor APIs at <code>https://github.com/angular/protractor/blob/master/docs/api.md</code>.</p>

<p>Much like <code>Karma</code> is the test runner for unit tests, we use Protractor to run end-to-end tests. Try it with npm run protractor. End-to-end tests are slow, so unlike with unit tests, Protractor will exit after the test run and will not automatically rerun the test suite on every file change. To rerun the test suite, execute npm run protractor again.</p>

<pre><code>Note: You must ensure you've installed the protractor and updated webdriver prior to running the npm run protractor. You can do this by issuing npm install and npm run update-webdriver into your terminal.
</code></pre>

<h2>Angularjs迭代器过滤演示</h2>

<p><a href="/phonecat/step-3/app/">Angularjs迭代器过滤</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angularjs学习笔记-动态模板]]></title>
    <link href="http://blog.dofa.org/blog/2014/04/07/learning-angularjs-notes-dynamic-templates/"/>
    <updated>2014-04-07T16:10:10-07:00</updated>
    <id>http://blog.dofa.org/blog/2014/04/07/learning-angularjs-notes-dynamic-templates</id>
    <content type="html"><![CDATA[<p>AngularJS应用使用模型-视图-控制器（MVC）模式解耦代码和分离关注点。</p>

<h2>视图和模板</h2>

<p>在<code>AngularJS</code>中，一个视图是模型通过HTML<strong>模板</strong>渲染之后的映射。这意味着，不论模型什么时候发生变化，<code>AngularJS</code>会实时更新结合点，随之更新视图。</p>

<p>视图组件被AngularJS用下面这个模板构建出来:</p>

<p><code>app/index.html</code>:</p>

<pre><code>&lt;html ng-app="phonecatApp"&gt;
&lt;head&gt;
  ...
  &lt;script src="../bower_components/angular/angular.js"&gt;&lt;/script&gt;
  &lt;script src="js/controllers.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body ng-controller="PhoneListCtrl"&gt;

  &lt;ul&gt;
    &lt;li ng-repeat="phone in phones"&gt;
      
      &lt;p&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>我们刚刚把静态编码的手机列表替换掉了，因为这里我们使用<code>ngRepeat</code>指令和两个用花括号包裹起来的<code>AngularJS</code>表达式——<code>{{phone.name}}</code>
和<code>{{phone.snippet}}</code>——能达到同样的效果。</p>

<p>在<code>&lt;li&gt;</code>标签里面的<code>ng-repeat="phone in phones"</code>语句是一个<code>AngularJS</code>迭代器。这个迭代器告诉<code>AngularJS</code>用第一个<code>&lt;li&gt;</code>标签作为模板为列表中的每一部手机创建一个<code>&lt;li&gt;</code>元素。
正如我们在第0步时学到的，包裹在<code>phone.name</code>和<code>phone.snippet</code>周围的花括号标识着数据绑定。和常量计算不同的是，这里的表达式实际上是我们应用的一个数据模型引用，这些我们在<code>PhoneListCtrl</code>控制器里面都设置好了。</p>

<h2>模型和控制器</h2>

<p>在<code>PhoneListCtrl</code>控制器里面初始化了数据模型（这里只不过是一个包含了数组的函数，数组中存储的对象是手机数据列表）：</p>

<p><code>app/js/controller.js:</code></p>

<pre><code>var phonecatApp = angular.module('phonecatApp', []);

phonecatApp.controller('PhoneListCtrl', function ($scope) {
  $scope.phones = [
    {'name': 'Nexus S',
     'snippet': 'Fast just got faster with Nexus S.'},
    {'name': 'Motorola XOOM™ with Wi-Fi',
     'snippet': 'The Next, Next Generation tablet.'},
    {'name': 'MOTOROLA XOOM™',
     'snippet': 'The Next, Next Generation tablet.'}
  ];
});
</code></pre>

<p>尽管控制器看起来并没有起到什么控制的作用，但是它在这里起到了至关重要的作用。通过给定我们数据模型的语境，控制器允许我们建立模型和视图之间的数据绑定。我们是这样把表现层，数据和逻辑部件联系在一起的：</p>

<ul>
<li><code>PhoneListCtrl</code>——控制器方法的名字（在JS文件<code>controllers.js</code>中）和<code>&lt;body&gt;</code>标签里面的<code>ngController</code>指令的值相匹配。</li>
<li>手机的数据此时与注入到我们控制器函数的作用域（<code>$scope</code>）相关联。当应用启动之后，会有一个根作用域被创建出来，而控制器的作用域是根作用域的一个典型后继。这个控制器的作用域对所有<code>&lt;body ng-controller="PhoneListCtrl"&gt;</code>标记内部的数据绑定有效。</li>
</ul>


<p><code>AngularJS</code>的作用域理论非常重要：一个作用域可以视作模板、模型和控制器协同工作的粘接器。<code>AngularJS</code>使用作用域，同时还有模板中的信息，数据模型和控制器。这些可以帮助模型和视图分离，但是他们两者确实是同步的！任何对于模型的更改都会即时反映在视图上；任何在视图上的更改都会被立刻体现在模型中。</p>

<h2>测试</h2>

<p>“AngularJS方式”让开发时代码测试变得十分简单。让我们来瞅一眼下面这个为控制器新添加的单元测试：</p>

<p><code>test/unit/controllersSpec.js:</code></p>

<pre><code>describe('PhoneCat controllers', function() {

  describe('PhoneListCtrl', function(){

    it('should create "phones" model with 3 phones', function() {
      var scope = {},
      ctrl = new PhoneListCtrl(scope);

      expect(scope.phones.length).toBe(3);
    });
  });
});
</code></pre>

<p>The test instantiates <code>PhoneListCtrl</code> and verifies that the phones array property on the scope contains three records. This example demonstrates how easy it is to create a unit test for code in Angular. Since testing is such a critical part of software development, we make it easy to create tests in Angular so that developers are encouraged to write them.</p>

<p>Note: 进入下一步之前要安装<code>karma</code></p>

<pre><code>npm install -g karma
</code></pre>

<p>出现问题试试下面的命令：</p>

<pre><code>npm install -g karma-cli

npm install -g zeparser

npm install npm -g

npm config set strict-ssl false
</code></pre>

<p>另外注意看<code>debug.log</code>查看缺失的包，然后安装上去</p>

<h2>Testing non-Global Controllers</h2>

<p>In practice, you will not want to have your controller functions in the global namespace. Instead, you can see that we have registered it via an anonymous constructor function on the <code>phoneCatApp</code> module.</p>

<p>In this case Angular provides a service, <code>$controller</code>, which will retrieve your controller by name. Here is the same test using <code>$controller</code>:</p>

<p><code>test/unit/controllersSpec.js:</code></p>

<pre><code>describe('PhoneListCtrl', function(){

  beforeEach(module('phonecatApp'));

  it('should create "phones" model with 3 phones', inject(function($controller) {
    var scope = {},
        ctrl = $controller('PhoneListCtrl', {$scope:scope});

    expect(scope.phones.length).toBe(3);
  }));

});
</code></pre>

<ul>
<li>Before each test we tell Angular to load the <code>phonecatApp</code> module.</li>
<li>We ask Angular to inject the <code>$controller</code> service into our test function</li>
<li>We use <code>$controller</code> to create an instance of the <code>PhoneListCtrl</code></li>
<li>With this instance, we verify that the phones array property on the scope contains three records.</li>
</ul>


<h2>Writing and Running Tests</h2>

<p>Angular developers prefer the syntax of Jasmine&rsquo;s Behavior-driven Development (BDD) framework when writing tests. Although Angular does not require you to use Jasmine, we wrote all of the tests in this tutorial in Jasmine v1.3. You can learn about Jasmine on the Jasmine home page and at the Jasmine docs.</p>

<p>The angular-seed project is pre-configured to run unit tests using Karma but you will need to ensure that Karma and its necessary plugins are installed. You can do this by running npm install.</p>

<p>To run the tests, and then watch the files for changes: npm test.</p>

<ul>
<li>Karma will start a new instance of Chrome browser automatically. Just ignore it and let it run in the background. Karma will use this browser for test execution.</li>
<li><p>You should see the following or similar output in the terminal:</p>

<p>  info: Karma server started at <a href="http://localhost:9876/">http://localhost:9876/</a>
  info (launcher): Starting  browser &ldquo;Chrome&rdquo;
  info (Chrome 22.0): Connected on socket id tPUm9DXcLHtZTKbAEO-n
  Chrome 22.0: Executed 1 of 1 SUCCESS (0.093 secs / 0.004 secs)</p></li>
</ul>


<p>Yay! The test passed! Or not&hellip;</p>

<ul>
<li>To rerun the tests, just change any of the source or test .js files. Karma will notice the change and will rerun the tests for you. Now isn&rsquo;t that sweet?</li>
</ul>


<h2>Angularjs动态模板演示</h2>

<p><a href="/phonecat/step-2/app/">Angularjs动态模板</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angularjs学习笔记-静态模板]]></title>
    <link href="http://blog.dofa.org/blog/2014/04/07/learning-angularjs-notes-static-templates/"/>
    <updated>2014-04-07T15:57:25-07:00</updated>
    <id>http://blog.dofa.org/blog/2014/04/07/learning-angularjs-notes-static-templates</id>
    <content type="html"><![CDATA[<p>Angularjs下静态页面的创建和普通<code>HTML</code>页面相同，可以直接看效果。</p>

<h2>Angularjs静态模板演示</h2>

<p><a href="/phonecat/step-1/app/">Angularjs静态模板</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解JavaScript中的事件处理]]></title>
    <link href="http://blog.dofa.org/blog/2014/04/05/understanding-of-javascript-event-handling/"/>
    <updated>2014-04-05T09:37:25-07:00</updated>
    <id>http://blog.dofa.org/blog/2014/04/05/understanding-of-javascript-event-handling</id>
    <content type="html"><![CDATA[<p>这篇文章对于了解Javascript的事件处理机制非常好，将它全文转载于此，以备不时之需。</p>

<h2>什么是事件？</h2>

<p>事件(<code>Event</code>)是<code>JavaScript</code>应用跳动的心脏 ，也是把所有东西粘在一起的胶水。当我们与浏览器中 <code>Web</code> 页面进行某些类型的交互时，事件就发生了。事件可能是用户在某些内容上的点击、鼠标经过某个特定元素或按下键盘上的某些按键。事件还可能是 <code>Web</code> 浏览器中发生的事情，比如说某个 <code>Web</code> 页面加载完成，或者是用户滚动窗口或改变窗口大小。</p>

<p>通过使用 <code>JavaScript</code> ，你可以监听特定事件的发生，并规定让某些事件发生以对这些事件做出响应。</p>

<h2>今天的事件</h2>

<p>在漫长的演变史，我们已经告别了内嵌式的事件处理方式（直接将事件处理器放在 <code>HTML</code> 元素之内来使用）。今天的事件，它已是DOM的重要组成部分，遗憾的是， <code>IE</code>继续保留它最早在<code>IE4.0</code>中实现的事件模型，以后的<code>IE</code>版本中也没有做太大的改变，这也就是说<code>IE</code>还是使用的是一种专有的事件模型（冒泡型）,而其它的主流浏览器直到<code>DOM</code> 级别 3 规定定案后，才陆陆续续支持<code>DOM</code>标准的事件处理模型 — 捕获型与冒泡型。</p>

<blockquote><p>历史原因是：<code>W3C</code> 规范 在<code>DOM</code> 级别 1中并没有定义任何的事件，直到发布于 2000 年 11 月 的<code>DOM</code> 级别 2 才定义了一小部分子集，<code>DOM</code> 级别 2中已经提供了提供了一种更详细的更细致的方式以控制 <code>Web</code> 页面中的事件，最后，完整的事件是在2004年 <code>DOM</code> 级别 3的规定中才最终定案。因为<code>IE4</code>是1995推出的并已实现了自己的事件模型（冒泡型），当时根本就没有<code>DOM</code>标准，不过在以后的<code>DOM</code>标准规范过程中已经把IE的事件模型吸收到了其中。</p></blockquote>

<p>目前除<code>IE</code>浏览器外，其它主流的<code>Firefox</code>, <code>Opera</code>,
<code>Safari</code>都支持标准的<code>DOM</code>事件处理模型。<code>IE</code>仍然使用自己专有的事件模型，即冒泡型，它事件模型的一部份被<code>DOM</code>标准采用，这点对于开发者来说也是有好处的，只有使用
<code>DOM</code>标准，<code>IE</code>都共有的事件处理方式才能有效的跨浏览器。</p>

<h2>DOM事件流</h2>

<p><code>DOM</code>(文档对象模型)结构是一个树型结构，当一个<code>HTML</code>元素产生一个事件时，该事件会在元素结点与根节点之间按特定的顺序传播，路径所经过的节点都会收到该事件，这个传播过程可称为<code>DOM</code>事件流。</p>

<p>事件顺序有两种类型：<strong>事件捕捉</strong>和<strong>事件冒泡</strong>。</p>

<h4>冒泡型事件(Event Bubbling)</h4>

<p>这是<code>IE</code>浏览器对事件模型的实现，也是最容易理解的，至少笔者觉得比较符合实际的。冒泡，顾名思义，事件像个水中的气泡一样一直往上冒，直到顶端。从<code>DOM</code>树型结构上理解，就是事件由叶子节点沿祖先结点一直向上传递直到根节点；从浏览器界面视图<code>HTML</code>元素排列层次上理解就是事件由具有从属关系的最确定的目标元素一直传递到最不确定的目标元素.冒泡技术.冒泡型事件的基本思想,事件按照从特定的事件目标开始到最不确定的事件目标.</p>

<h4>捕获型事件(Event Capturing)</h4>

<p><code>Netscape</code>的实现，它与冒泡型刚好相反，由<code>DOM</code>树最顶层元素一直到最精确的元素，这个事件模型对于开发者来说（至少是我..）有点费解，因为直观上的理解应该如同冒泡型，事件传递应该由最确定的元素，即事件产生元素开始。</p>

<p><img src="http://dofa.u.qiniudn.com/image/web/javascript-event-module.jpg"></p>

<h4>DOM标准的事件模型</h4>

<p>我们已经对上面两个不同的事件模型进行了解释和对比。<code>DOM</code>标准同时支持两种事件模型，即捕获型事件与冒泡型事件，但是，捕获型事件先发生。两种事件流都会触发<code>DOM</code>中的所有对象，从<code>document</code>对象开始，也在<code>document</code>对象结束（大部分兼容标准的浏览器会继续将事件是捕捉/冒泡延续到<code>window</code>对象）。</p>

<p><img src="http://dofa.u.qiniudn.com/image/web/javascript-event-dom.jpg"></p>

<p>如图：首先是捕获式传递事件，接着是冒泡式传递，所以，如果一个处理函数既注册了捕获型事件的监听，又注册冒泡型事件监听，那么在<code>DOM</code>事件模型中它就会被调用两次。</p>

<p><code>DOM</code>标准的事件模型最独特的性质是,文本节点也会触发事件(在IE不会)。</p>

<p><img src="http://dofa.u.qiniudn.com/image/web/javascript-event-trans.png"></p>

<h4>事件传送</h4>

<p>为了更好的说明<code>DOM</code>标准中的事件流原理，我们把它放在“事件传送”小结里来更具体的解释。</p>

<p>显然，如果为一个超链接添加了<code>click</code>事件监听器，那么当该链接被点击时该事件监听器就会被执行。但如果把该事件监听器指派给了包含该链接的<code>p</code>元素或者位于<code>DOM</code>树顶端的<code>document</code>节点，那么点击该链接也同样会触发该事件监听器。这是因为事件不仅仅对触发的目标元素产生影响，它们还会对沿着DOM结构的所有元素产生影响。这就是大家所熟悉的<em>事件转送</em>。</p>

<p><code>W3C</code>事件模型中明确地指出了事件转送的原理。事件传送可以分为3个阶段。</p>

<p><img src="http://dofa.u.qiniudn.com/image/web/javascript-event-trans2.png"></p>

<p>如图：标准的事件转送模式</p>

<ul>
<li>在事件捕捉（<code>Capturing</code>）阶段，事件将沿着<code>DOM</code>树向下转送，目标节点的每一个祖先节点，直至目标节点。例如，若用户单击了一个超链接，则该单击事件将从<code>document</code>节点转送到<code>html</code>元素，<code>body</code>元素以及包含该链接的<code>p</code>元素。</li>
</ul>


<p>在此过程中，浏览器都会检测针对该事件的捕捉事件监听器，并且运行这件事件监听器。</p>

<ul>
<li><p>在目标（<code>target</code>）阶段，浏览器在查找到已经指定给目标事件的事件监听器之后，就会运行 该事件监听器。目标节点就是触发事件的<code>DOM</code>节点。例如，如果用户单击一个超链接，那么该链接就是目标节点（此时的目标节点实际上是超链接内的文本节点）。</p></li>
<li><p>在冒泡（<code>Bubbling</code>）阶段，事件将沿着<code>DOM</code>树向上转送，再次逐个访问目标元素的祖先节点到<code>document</code>节点。该过程中的每一步。浏览器都将检测那些不是捕捉事件监听器的事件监听器，并执行它们。</p></li>
</ul>


<blockquote><p>并非所有的事件都会经过冒泡阶段的</p>

<p>所有的事件都要经过捕捉阶段和目标阶段，但是有些事件会跳过冒泡阶段。例如，让元素获得输入焦点的<code>focus</code>事件以及失去输入焦点的<code>blur</code>事件就都不会冒泡。</p></blockquote>

<h2>事件句柄和事件接听器</h2>

<h4>事件句柄</h4>

<p>事件句柄（又称事件处理函数，<code>DOM</code>称之为事件监听函数），用于响应某个事件而调用的函数称为事件处理函数
。每一个事件均对应一个事件句柄，在程序执行时，将相应的函数或语句指定给事件句柄，则在该事件发生时，浏览器便执行指定的函数或语句，从而实现网页内容与用户操作的交互。当浏览器检测到某事件发生时，便查找该事件对应的事件句柄有没有被赋值，如果有，则执行该事件句柄。</p>

<p>我们认为响应点击事件的函数是<code>onclick</code>事件处理函数。以前，事件处理函数有两种分配方式：在<code>JavaScript</code>中或者在<code>HTML</code>中。</p>

<p>如果在<code>JavaScript</code>中分配事件处理函数，则需要首先获得要处理的对象的一引用，然后将函数赋值给对应的事件处理函数属性，请看一个简单的例子：</p>

<pre><code>var link=document.getElementById("mylink");
link.onclick=function(){
  alert("I was clicked !");
}; 
</code></pre>

<p>从我们看到的例子中，我们发现使用事件句柄很容易，
不过事件处理函数名称必须是小写的，还有就是只有在
元素载入完成之后才能将事件句柄赋给元素，不然会有异常。</p>

<p>如果在<code>HTML</code>中分配事件句柄的话，则直接通过<code>HTML</code>属性来设置事件处理函数就行了，并在其中包含合适的脚本作为特性值就可以了，例如：</p>

<pre><code>&lt;a href="http://blog.dofa.org/" onclick="JavaScript code here"&gt;......&lt;/a&gt;
</code></pre>

<p>这种<code>JavaScript</code>代码和通过<code>HTML</code>的<code>style</code>属性直接将<code>CSS</code>属性赋给元素类似。这样会代码看起来一团糟，也违背了将实现动态行为的代码与显示文档静态内容的代码相分离的原则。从1998年开始，这种写法就过时了。</p>

<h4>这种传统的事件绑定技术，优缺点是显然的：</h4>

<ul>
<li><p>简单方便，在<code>HTML</code>中直接书写处理函数的代码块，在JS中给元素对应事件属性赋值即可。</p></li>
<li><p><code>IE</code>与<code>DOM</code>标准都支持的一种方法，它在<code>IE</code>与<code>DOM</code>标准中都是在事件冒泡过程中被调用的。</p></li>
<li><p>可以在处理函数块内直接用<code>this</code>引用注册事件的元素，<code>this</code>引用的是当前元素。</p></li>
<li><p>要给元素注册多个监听器，就不能用这方法了。</p></li>
</ul>


<h4>事件接听器</h4>

<p>除了前面已经介绍的简单事件句柄之外，现在大多数浏览器都内置了一些更高级的事件处理方式，即，事件监听器，这种处理方式就不受一个元素只能绑定一个事件句柄的限制。</p>

<p>我们已经知道了事件句柄与事件监听器的最大不同之处是使用事件句柄时一次只能插接一个事件句柄，但对于事件监听器，一次可以插接多个。</p>

<h4>IE下的事件监听器：</h4>

<p><code>IE</code>提供的却是一种自有的，完全不同的甚至存在<code>BUG</code>的事件监听器，因此如果要让脚本在本浏览器中正常运行的话，就必须使用<code>IE</code>所支持的事件监听器。另外，<code>Safari</code>浏览器中的事件监听器有时也存在一点不同。</p>

<p>在<code>IE</code>中，每个元素和<code>window</code>对象都有两个方法：<code>attachEvent</code>方法和<code>detachEvent</code>方法。</p>

<pre><code>element.attachEvent("onevent",eventListener);
</code></pre>

<p>此方法的意思是在<code>IE</code>中要想给一个元素的事件附加事件处理函数，必须调用<code>attachEvent</code>方法才能创建一个事件监听器。<code>attachEvent</code>方法允许外界注册该元素多个事件监听器。</p>

<p><code>attachEvent</code>接受两个参数。第一个参数是事件类型名，第二个参数<code>eventListener</code>是回调处理函数。这里得说明一下，有个经常会出错的地方，IE下
利用<code>attachEvent</code>注册的处理函数调用时<code>this</code>指向不再是先前注册事件的元素，这时的<code>this</code>为<code>window</code>对象。还有一点是此方法的事件类型名称必须加上一个<code>on</code>的前缀（如<code>onclick</code>）。</p>

<pre><code>element.attachEvent("onevent",eventListener);
</code></pre>

<p>要想移除先前元素注册的事件监听器,可以使用<code>detachEvent</code>方法进行删除，参数相同。</p>

<h4>DOM标准下的事件监听器：</h4>

<p>在支持<code>W3C</code>标准事件监听器的浏览器中，对每个支持事件的对象都可以使用<code>addEventListener</code>方法。该方法既支持注册冒泡型事件处理，又支持捕获型事件处理。所以与IE浏览器中注册元素事件监听器方式有所不同的。</p>

<pre><code>//标准语法 
element.addEventListener('event', eventListener, useCapture);
//默认
element.addEventListener('event', eventListener, false);
</code></pre>

<p><code>addEventListener</code>方法接受三个参数。第一个参数是事件类型名，值得注意的是，这里事件类型名称与<code>IE</code>的不同，事件类型名是没<code>on</code>开头的;第二个参数<code>eventListener</code>是回调处理函数（即监听器函数）;第三个参数注明该处理回调函数是在事件传递过程中的捕获阶段被调用还是冒泡阶段被调用 ，通常此参数通常会设置为<code>false</code>（为<code>false</code>时是冒泡）,那么，如果将其值设置为<code>true</code>，那就创建一个捕捉事件监听器。</p>

<p>移除已注册的事件监听器调用<code>element</code>的<code>removeEventListener</code>方法即可，参数相同。</p>

<pre><code>//标准语法 
element.removeEventListener('event', eventListener, useCapture);
//默认
element.removeEventListener('event', eventListener, false); 
</code></pre>

<blockquote><p>通过<code>addEventListener</code>方法添加的事件处理函数，必须使用<code>removeEventListener</code>方法才能删除，而且要求参数与添加事件处理函数时<code>addEventListener</code>方法的参数完全一致（包括<code>useCapture</code>参数），否则将不能成功删除事件处理函数。</p></blockquote>

<h4>跨浏览器的注册与移除元素事件监听器方案</h4>

<p>我们现在已经知道，对于支持<code>addEventListener</code>方法的浏览器，只要需要事件监听器脚本就都需要调用<code>addEventListener</code>方法；而对于不支持该方法的IE浏览器，使用事件监听器时则需要调用<code>attachEvent</code>方法。要确保浏览器使用正确的方法其实并不困难，只需要通过一个<code>if-else</code>语句来检测当前浏览器中是否存在<code>addEventListener</code>方法或<code>attachEvent</code>方法即可。</p>

<p>这样的方式就可以实现一个跨浏览器的注册与移除元素事件监听器方案:</p>

<pre><code>var EventUtil = {
  //注册
  addHandler: function(element, type, handler){
    if (element.addEventListener){
      element.addEventListener(type, handler, false);
    } else if (element.attachEvent){
      element.attachEvent("on" + type, handler);
    } else {
      element["on" + type] = handler;
    }
  },
  //移除注册
  removeHandler: function(element, type, handler){
    if (element.removeEventListener){
            element.removeEventListener(type, handler, false);
    } else if (element.detachEvent){
            element.detachEvent("on" + type, handler);
    } else {
            element["on" + type] = null;
    }
  }             
 }; 
</code></pre>

<h4>事件对象引用</h4>

<p>为了更好的处理事件，你可以根据所发生的事件的特定属性来采取不同的操作。</p>

<p>如事件模型一样，IE 和其他浏览器处理方法不同：<code>IE</code>使用一个叫做<code>event</code>的全局事件对象来处理对象（它可以在全局变量<code>window.event</code>中找到），而其它所有浏览器采用的<code>W3C</code>推荐的方式，则使用独立的包含事件对象的参数传递。</p>

<p>跨浏览器实现这样的功能时，最常见的问题就是获取事件本身的引用及获取该事件的目标元素的引用。</p>

<p>下面这段代码就为你解决了这个问题：</p>

<pre><code>var EventUtil ={
  getEvent: function(event){
    return event ? event : window.event;
  },
  getTarget: function(event){
    return event.target || event.srcElement;
  }
}; 
</code></pre>

<h2>停止事件冒泡和阻止事件的默认行为</h2>

<p>“停止事件冒泡“和”阻止浏览器的默认行为“，这两个概念非常重要，它们对复杂的应用程序处理非常有用。</p>

<ul>
<li>停止事件冒泡</li>
</ul>


<p>停止事件冒泡是指，停止冒泡型事件的进一步传递（取消事件传递,不只是停止<code>IE</code>和<code>DOM</code>标准共有的冒泡型事件，我们还可以停止支持DOM标准浏览器的捕捉型事件，用<code>topPropagation()</code>方法）。例如上图中的冒泡型事件传递中，在<code>body</code>处理停止事件传递后，位于上层的<code>document</code>的事件监听器就不再收到通知，不再被处理。</p>

<ul>
<li>阻止事件的默认行为</li>
</ul>


<p>停止事件的默认行为是指，通常浏览器在事件传递并处理完后会执行与该事件关联的默认动作（如果存在这样的动作）。例如，如果表单中<code>input type</code>属性是<code>submit</code>，点击后在事件传播完浏览器就自动提交表单。又例如，<code>input</code> 元素的<code>keydown</code>事件发生并处理后，浏览器默认会将用户键入的字符自动追加到<code>input</code>元素的值中。</p>

<h4>停止事件冒泡的处理方法：</h4>

<p>在<code>IE</code>下,通过设置<code>event</code>对象的<code>cancelBubble</code>为<code>true</code>即可。</p>

<pre><code>function someHandle() {
  window.event.cancelBubble = true;
}
</code></pre>

<p><code>DOM</code>标准通过调用<code>event</code>对象的<code>stopPropagation()</code>方法即可。</p>

<pre><code>function someHandle(event) {
  event.stopPropagation();
}
</code></pre>

<p>因些，跨浏览器的停止事件传递的方法是:</p>

<pre><code>function someHandle(event) {
  event = event || window.event;
  if(event.stopPropagation){
    event.stopPropagation();
  }else {
    event.cancelBubble = true;
  }
}   
</code></pre>

<h4>阻止事件的默认行为的处理方法</h4>

<p>就像事件模型和事件对象差异一样，在<code>IE</code>和其它所有浏览器中阻止事件的默认行为的方法也不同。</p>

<p>在<code>IE</code>下,通过设置<code>event</code>对象的<code>returnValue</code>为<code>false</code>即可。</p>

<pre><code>function someHandle() {
  window.event.returnValue = false;
}
</code></pre>

<p><code>DOM</code>标准通过调用<code>event</code>对象的<code>preventDefault()</code>方法即可。</p>

<pre><code>function someHandle(event) {
  event.preventDefault();
}
</code></pre>

<p>因些，跨浏览器的取消事件传递后的默认处理方法是：</p>

<pre><code>function someHandle(event) {
  event = event || window.event;
  if(event.preventDefault){
    event.preventDefault();
  }else{
    event.returnValue = false;
  }
}
</code></pre>

<p>完整的事件处理兼容性函数</p>

<pre><code>var EventUtil = {
  addHandler: function(element, type, handler){
    if (element.addEventListener){
      element.addEventListener(type, handler, false);
    } else if (element.attachEvent){
      element.attachEvent("on" + type, handler);
    } else {
      element["on" + type] = handler;
    }
  },
  removeHandler: function(element, type, handler){
    if (element.removeEventListener){
      element.removeEventListener(type, handler, false);
    } else if (element.detachEvent){
      element.detachEvent("on" + type, handler);
    } else {
      element["on" + type] = null;
    }
  },
  getEvent: function(event){
    return event ? event : window.event;
  },
  getTarget: function(event){
    return event.target || event.srcElement;
  },
  preventDefault: function(event){
    if (event.preventDefault){
      event.preventDefault();
    } else {
      event.returnValue = false;
    }
  },
  stopPropagation: function(event){
    if (event.stopPropagation){
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
};  
</code></pre>

<h2>捕获型事件模型与冒泡型事件模型的应用场合</h2>

<p>标准事件模型为我们提供了两种方案，可能很多朋友分不清这两种不同模型有啥好处，为什么不只采取一种模型。
这里抛开IE浏览器讨论（<code>IE</code>只有一种，没法选择）什么情况下适合哪种事件模型。</p>

<ul>
<li>捕获型应用场合</li>
</ul>


<p>捕获型事件传递由最不精确的祖先元素一直到最精确的事件源元素，传递方式与操作系统中的全局快捷键与应用程序快捷键相似。当一个系统组合键发生时，如果注
册了系统全局快捷键监听器，该事件就先被操作系统层捕获，全局监听器就先于应用程序快捷键监听器得到通知，也就是全局的先获得控制权，它有权阻止事件的进
一步传递。所以捕获型事件模型适用于作全局范围内的监听，这里的全局是相对的全局，相对于某个顶层结点与该结点所有子孙结点形成的集合范围。</p>

<p>例如你想作全局的点击事件监听，相对于<code>document</code>结点与<code>document</code>下所有的子结点，在某个条件下要求所有的子结点点击无效，这种情况下冒泡模型就解决不了了，而捕获型却非常适合，可以在最顶层结点添加捕获型事件监听器，伪码如下:</p>

<pre><code>function globalClickListener(event) {
  if(canEventPass == false) {
    //取消事件进一步向子结点传递和冒泡传递
    event.stopPropagation();
    //取消浏览器事件后的默认执行
    event.preventDefault();
  }
}
</code></pre>

<p>这样一来，当<code>canEventPass</code>条件为假时，<code>document</code>下所有的子结点<code>click</code>注册事件都不会被浏览器处理。</p>

<ul>
<li>冒泡型的应用场合</li>
</ul>


<p>可以说我们平时用的都是冒泡事件模型，因为<code>IE</code>只支持这模型。这里还是说说，在恰当利用该模型可以提高脚本性能。在元素一些频繁触发的事件中，如<code>onmousemove</code>,
<code>onmouseover</code>, <code>onmouseout</code>,如果明确事件处理后没必要进一步传递，那么就可以大胆的取消它。此外，对于子结点事件监听器的处理会对父
层监听器处理造成负面影响的，也应该在子结点监听器中禁止事件进一步向上传递以消除影响。</p>

<h4>综合案例分析.</h4>

<p>最后结合下面HTML代码作分析:</p>

<pre><code>&lt;body onclick="alert('current is body');"&gt;
  &lt;div id="div0" onclick="alert('current is '+this.id)"&gt;
    &lt;div id="div1" onclick="alert('current is '+this.id)"&gt;
      &lt;div id="div2" onclick="alert('current is '+this.id)"&gt;
        &lt;div id="event_source" onclick="alert('current is '+this.id)" style="height:200px;width:200px;background-color:red;"&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p><code>HTML</code>运行后点击红色区域,这是最里层的<code>DIV</code>,根据上面说明,无论是<code>DOM</code>标准还是<code>IE</code>,直接写在<code>html</code>里的监听处理函数是事件冒泡传递时调用的,由最里层一直往上传递,所以会先后出现</p>

<pre><code>current is event_source
current is div2
current is div1
current is div0
current is body
</code></pre>

<p>添加以下片段:</p>

<pre><code>var div2 = document.getElementById('div2');
EventUtil.addHandler(div2, 'click', function(event){
  event = EventUtil.getEvent(event);
  EventUtil.stopPropagation(event);
}, false);
</code></pre>

<p>结果:</p>

<pre><code>current is event_sourcecurrent is div2
</code></pre>

<p>当点击红色区域后,根据上面说明,在泡冒泡处理期间,事件传递到<code>div2</code>后被停止传递了,所以<code>div2</code>上层的元素收不到通知,所以会先后出现:</p>

<p>在支持<code>DOM</code>标准的浏览器中,添加以下代码:</p>

<pre><code>document.body.addEventListener('click', function(event){
  event.stopPropagation();
}, true);
</code></pre>

<p>以上代码中的监听函数由于是捕获型传递时被调用的,所以点击红色区域后,虽然事件源是<code>ID</code>为<code>event_source</code>的元素,但捕获型选传递,从最顶层开始,body结点监听函数先被调用,并且取消了事件进一步向下传递,所以只会出现 <code>current is body</code>。</p>
]]></content>
  </entry>
  
</feed>
